<h2 id="the_search_tab">The <em>Search</em> tab</h2>

<h3 id="the_search_tab_i">Layout and interface</h3>

<p>The Search tab - the first tab that the user will see when launching our app - is going to
be a search form for the user to search our Japanese dictionary. It will also display any and all
matching results in a scrollable area.</p>
<p>We'll have a rule that the user's search query can be in Japanese as well as English. Not only
will this increase the usefulness of our app, it will also enable a future "reversing" of the
app to be localised for Japanese speakers wanting to learn English vocabulary.
Let's have another rule that they can type the Japanese or English query into the form
in the same input box and without having to fiddle with radio buttons or other such inputs
(which are a bit old hat for search forms anyway but especially cumbersome on mobile devices).
With these rules and functionalities in mind, a wireframe of the Search tab might look like:</p>

<div class="figure">
    <img src="img/figure/fig_260.png">
    <p>Figure 26. Quick wireframe of the Search tab layout</p>
</div>


<p>OK, let's markup - and then style - the search form and the results space for dictionary queries.
Mosey on down to <a href="http://www.ajaxload.info">http://www.ajaxload.info</a> and make a "loading" spinner image (gif) for the Search tab.
I made mine use the Japxlate signature red (#990000) and a transparent background.
Download it and put it in <code class="file">/assets/www/img</code> as <code class="file">spinner.gif</code>.</p>

<p>Let's markup the form and results space - in index.html - like this:</p>

<code class="multiline"><span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>div</span> id=<span style='color:#2a00ff; '>"search"</span> class=<span style='color:#2a00ff; '>"current"</span><span style='color:#7f0055; '>></span>
    <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>button</span> type=<span style='color:#2a00ff; '>"button"</span> id=<span style='color:#2a00ff; '>"search-button"</span> style=<span style='color:#2a00ff; '>"</span><span style='color:#7f0055; font-weight:bold; '>float</span>:right; <span style='color:#7f0055; font-weight:bold; '>width</span>:45%; <span style='color:#7f0055; font-weight:bold; '>margin-right</span>:1%;<span style='color:#2a00ff; '>"</span><span style='color:#7f0055; '>></span>
        <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>img</span> src=<span style='color:#2a00ff; '>"img/search.png"</span><span style='color:#7f0055; '>></span>
        Search
        <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>img</span> id=<span style='color:#2a00ff; '>"button-spinner"</span> src=<span style='color:#2a00ff; '>"img/spinner.gif"</span> style=<span style='color:#2a00ff; '>"</span><span style='color:#7f0055; font-weight:bold; '>visibility</span>:hidden;<span style='color:#2a00ff; '>"</span><span style='color:#7f0055; '>></span>
    <span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>button</span><span style='color:#7f0055; '>></span>
    <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>input</span> type=<span style='color:#2a00ff; '>"text"</span> id=<span style='color:#2a00ff; '>"search-query"</span> placeholder=<span style='color:#2a00ff; '>"Japanese or English"</span> size=<span style='color:#2a00ff; '>"40"</span>
           style=<span style='color:#2a00ff; '>"</span><span style='color:#7f0055; font-weight:bold; '>width</span>:45%; <span style='color:#7f0055; font-weight:bold; '>margin-left</span>:1%;<span style='color:#2a00ff; '>"</span><span style='color:#7f0055; '>></span>
    <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>br</span><span style='color:#7f0055; '>></span>
    <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>span</span> id=<span style='color:#2a00ff; '>"loading-text"</span><span style='color:#7f0055; '>></span>
        [Loading core dictionary. This takes a while the first time.
        <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>img</span> src=<span style='color:#2a00ff; '>"img/spinner.gif"</span><span style='color:#7f0055; '>></span>]
    <span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>span</span><span style='color:#7f0055; '>></span>
    <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>div</span> id=<span style='color:#2a00ff; '>"results-wrapper"</span><span style='color:#7f0055; '>></span>
        <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>div</span> id=<span style='color:#2a00ff; '>"search-results"</span><span style='color:#7f0055; '>></span>
            You can search by kanji, hiragana, katakana, English or romaji!
        <span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>div</span><span style='color:#7f0055; '>></span>
    <span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>div</span><span style='color:#7f0055; '>></span>
<span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>div</span><span style='color:#7f0055; '>></span></code>

<p>We float our search button right (which means that in the markup it has to come <em>before</em> things
on the same line that would be visually to the left of it) but make it 1% (of total width) away from the edge
for nice appearance. We reuse <code class="file">search.png</code> as a button icon. We also include the <code class="file">spinner.gif</code>
that we just created but default it to <code>visibility:hidden</code>. Why not just <code>display:none</code>? Because
with <code>visibility:hidden</code>, it is hidden but still takes up space in the layout flow. This means
the layout won't "jump" when we make it appear. We'll switch this image's visibility on and off
programmatically.</p>

<p>Then we've got our text input which uses the new HTML5 <code>placeholder</code> attribute to present a hint
or instruction to the user about what kind of entry it expects. The text input is also 45% wide
with an edge spacing of 1%.</p>

<p>Why not just make both 50%? Because then they will touch in the middle which will end in tears
with big fingers on a small display!</p>

<p>We then have a "this will take a while" message and spinner that we will remove after one-off
setup is complete.</p>

<p>Finally we have a container for our search results - &lt;div id="search-results"> - which
displays a default search hint. We also have a wrapper for the search results container -
&lt;div id="results-wrapper"> - which is going to be the scroll viewport for search results.
These two divs need the following styles in <code class="file">index.css</code>:</p>

<code class="multiline">#results-wrapper {
    <span style='color:#7f0055; font-weight:bold; '>position</span>:static;
    <span style='color:#7f0055; font-weight:bold; '>width</span>:100%;
    <span style='color:#7f0055; font-weight:bold; '>margin-top</span>:1em;     <span style='color:#3f7f59; '>/*space one &lt;br>(ish) from bottom of search form*/</span>
    <span style='color:#7f0055; font-weight:bold; '>overflow</span>:hidden;
}

#search-results {
    <span style='color:#7f0055; font-weight:bold; '>position</span>:relative;  <span style='color:#3f7f59; '>/*we position this relative to its *normal* position*/</span>
    <span style='color:#7f0055; font-weight:bold; '>top</span>:0;              <span style='color:#3f7f59; '>/*but set the normal top position anyway. We will*/</span>
    <span style='color:#7f0055; font-weight:bold; '>width</span>:100%;         <span style='color:#3f7f59; '>/*change this top value to affect a scroll*/</span>
}</code>

<p>The keypoint here is <code>position:relative;</code> on the search-results div which means
that we will be able to position it (ie. scroll it) relative to an unmoving
parent - the results-wrapper div. Running this looks like:</p>

<div class="figure">
    <img src="img/figure/fig_270.png">
    <p>Figure 27. Initial appearance of the Search tab</p>
</div>

<p>Not bad. Just two grumbles here.</p>
<ol>
<li>The height of the text area is lacking and also it's shorter
than the button. Let's even these two out. (Actually on my device the text
input and the button don't seem to be on the same baseline!)</li>
<li>Icon for search is screwy again - let's fix that like we
fixed the tab icons.</li>
</ol>

<p>In <code class="file">index.css</code>, change the existing:</p>

<code class="multiline"><span style='color:#7f0055; font-weight:bold; '>a</span> <span style='color:#7f0055; font-weight:bold; '>img</span>
{
    <span style='color:#7f0055; font-weight:bold; '>vertical-align</span>:middle;      <span style='color:#3f7f59; '>/*make more sensible relative to text baseline*/</span>
}</code>

<p>to:</p>

<code class="multiline"><span style='color:#7f0055; font-weight:bold; '>a</span> <span style='color:#7f0055; font-weight:bold; '>img</span>, <span style='color:#7f0055; font-weight:bold; '>button</span> <span style='color:#7f0055; font-weight:bold; '>img</span>
{
    <span style='color:#7f0055; font-weight:bold; '>vertical-align</span>:middle;      <span style='color:#3f7f59; '>/*make more sensible relative to text baseline*/</span>
}</code>

<p>Which covers (2). To fix (1), add this to <code class="file">index.css</code>:</p>

<code class="multiline"><span style='color:#7f0055; font-weight:bold; '>input</span>[type=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>text</span><span style='color:#2a00ff; '>"</span>], <span style='color:#7f0055; font-weight:bold; '>button</span> {
    <span style='color:#7f0055; font-weight:bold; '>height</span>:30px;
    <span style='color:#7f0055; font-weight:bold; '>margin</span>:0;
}</code>


<p>Running looks like this:</p>

<div class="figure">
    <img src="img/figure/fig_280.png">
    <p>Figure 28. Improved appearance of the Search tab</p>
</div>

<p>Better!</p>


<h3 id="the_search_tab_ii">Creating the database</h3>

<p>Now, let's also have a rule to the effect of dictionary searches working even when the mobile device is
<strong>offline</strong>. That is to say the app must use some kind of local storage on the device itself or the WebView browser.
Well, it turns out that the Android WebView supports something called Web SQL which is a small,
local implementation of an SQL database (specifically SQLite) in the browser. We can load
our Japanese dictionary into a client-side database and, based on the user's search term, query
it in whichever way we need to pull out matches.</p>

<div class="sidenote">
<strong>Important note about Web SQL</strong>

<p>Web SQL is an <strong>abandoned specification</strong> (see <a href="http://www.w3.org/TR/webdatabase/">http://www.w3.org/TR/webdatabase/</a>) that W3C no longer maintain, and I <strong>do not recommend</strong> that
you use it going forward in your owns apps! W3C's beef was that it was only being implemented using SQLite - obviously
they aren't in the business of standardising a piece of vendor lock in!
For similar reasons Mozilla (ie. Firefox browser) have chosen not to implement it right from the start.
I do kind of agree that bringing a <em>heavy</em> server-side thing to the client is a bit of an
odd move. In fact, traditional SQL on the back-end is somewhat in crisis itself thesedays in the world of NoSQL
datastores. Though it is very useful for mobile apps that might not be online and need to work with some data.</p>

<strong>Why are we using it for this tutorial?</strong>
<p>Somewhat for historical reasons but also because I know it will be perfect for <em>fuzzy</em> text searching.
I know from experience that it will "just work". When using PhoneGap we are lucky too because
"Cordova provides access to both interfaces (Web SQL and something else called Web Storage) for the minority of devices that don't already support them. Otherwise the built-in implementations apply."
</p>

<strong>What would be some alternatives?</strong>
<p>Ignoring PhoneGap and the world of mobile apps, Indexed DB (a W3C standard at <a href="http://www.w3.org/TR/IndexedDB/">http://www.w3.org/TR/IndexedDB/</a>) looks
to be picking up steam. Though <a href="caniuse.com">caniuse.com</a> tells me that support is currently <em>less</em> than that of
Web SQL. Also it hasn't made its way into PhoneGap at the time of writing.
Indexed DB mirrors the more modern style of NoSQL databases more closely.</p>

<p>I hope that future versions of the app (and this tutorial) can use Indexed DB.</p>

<p class="new_3_3_0">PhoneGap v3.3.0 now supports Indexed DB, <strong>but only if the underlying WebView supports it</strong>. At the time of writing this means only Windows Phone 8 and BlackBerry 10.</p>
</div>


<p>PhoneGap's (well actually Cordova's) Web SQL docs are at <a href="http://docs.phonegap.com/en/3.1.0/cordova_storage_storage.md.html">http://docs.phonegap.com/en/3.1.0/cordova_storage_storage.md.html</a>
As you can see, it's a fairly small implementation of an SQL database. But writing for it in JavaScript
with callbacks was a novelty for this grizzled MySQL hacker!</p>

<p>OK, let's crack on now with Web SQL initialisation for the first load of the Search tab.
Stick this cheeky call - to a function we're about to create - at the bottom of <code>firstLoadForTab_Search()</code>
in <code class="file">japxlate.js</code>:</p>

<code class="multiline">tryPopulateDB();</code>

<p>Let's create this function, and other functions to do with general Web SQL setup, in a new file in <code class="file">/assets/www/js</code>
called <code class="file">websql_core.js</code>. Create this file, and the first function we'll put in it is the <code>tryPopulateDB()</code>
we've just referenced. It will look like this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Open / create the "Japxlate" Web SQL database and - if it's not already</span>
<span style='color:#3f7f59; '>//present - create and populate the "edict" table</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> tryPopulateDB()
{
    <span style='color:#3f7f59; '>//version 1.0, 4 megabytes</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> db = window.openDatabase(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Japxlate</span><span style='color:#2a00ff; '>"</span>, <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>1.0</span><span style='color:#2a00ff; '>"</span>, <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Japxlate DB</span><span style='color:#2a00ff; '>"</span>, 4 * 1024 * 1024);
    
    db.transaction(checkDB);  <span style='color:#3f7f59; '>//only populate edict table if it not already exist</span>
}</code>


<p>PRO TIP: The Cordova docs on Web SQL are going to be very useful to reference when following this chapter.
They are at <a href="http://docs.phonegap.com/en/3.1.0/cordova_storage_storage.md.html">http://docs.phonegap.com/en/3.1.0/cordova_storage_storage.md.html</a>.
<span class="new_3_3_0">(The <a href="http://docs.phonegap.com/en/3.3.0/cordova_storage_storage.md.html">same page</a> for PhoneGap v3.3.0 removes the Web SQL reference, which to be honest
had at least one mistake in it, and instead points you to have a look at <a href="http://www.html5rocks.com/en/features/storage">http://www.html5rocks.com/en/features/storage</a>.)</span></p>

<p>We open a Web SQL database called Japxlate, at version 1.0, with a display name of "Japxlate DB" and
a size of 4 megabytes. I know from tinkering with the dictionary database for the <a href="https://twitter.com/japxlate">@japxlate</a> Twitter
channel that the core dictionary definitions will fit in 4 megabytes with a bit to spare.</p>

<p>Then we call <code>transaction()</code> on the returned database to run the query or queries in the
<code>checkDB()</code> function that we're about to implement.</p>

<p>Now's a good time to talk about the schema we'll use for the dictionary table. We'll call
the table "edict" as that's the name of the Japanese dictionary that powers it (at <a href="http://www.csse.monash.edu.au/~jwb/wwwjdicinf.html#dicfil_tag">http://www.csse.monash.edu.au/~jwb/wwwjdicinf.html#dicfil_tag</a>)
and the fields will be:</p>

<code>edict(id unique, kanji, kana, definition)</code>

<p>"id" will be an integer and a unique key to each record. "kanji" will hold the Chinese characters
that the word is written in. "kana" will hold the Japanese phonetic script that the word is written in.
Finally "definition" will hold one or more English language definitions for the word, separated by '/'.</p>

<p>Our <code>checkDB()</code> function needs to know if the edict table exists and is full. If not, create it and fill it.</p>

<p>The <code>checkDB()</code> function will receive a SQLTransaction object as a parameter from <code>db.transaction()</code>
Again in <code class="file">websql_core.js</code>, make <code>checkDB()</code> look like this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Check if "edict" table exists and has records</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> checkDB(tx)
{
    <span style='color:#3f7f59; '>//console.log('checkDB()');</span>
    tx.executeSql(<span style='color:#2a00ff; '>'SELECT COUNT(id) AS count FROM edict'</span>, [], successCheckDB, errorCheckDB);
}</code>

<p>We call <code>executeSql()</code> on the received SQLTransaction object which needs at least an SQL query 
as its first argument (and parameter values as the 2nd parameter if the query in the first argument uses parameter binding),
but can optionally take both a success and failure callback as 3rd and 4th parameter respectively.
Here we run a very simple query to get the count of rows - by id - in the edict table.
This query will throw an error if the edict table does not exist (but not if it exists and
is empty which is a condition we will knowingly ignore for this simple app).
We don't use parameter binding in this query so we provide an empty array as the 2nd parameter
simply because we need to "get" to the 3rd and 4th parameters.
We specify an error and a success callback.
Should the query fail we can assume that the table does not exist and therefore needs
to be created and populated. Let's look at the success callback first as it's simpler
and only has to clear the "database loading" message:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Callback for if checkDB() succeeds - ie. "edict" table present and full</span>
<span style='color:#3f7f59; '>//SO clear the "database loading" message</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> successCheckDB(tx, results)
{
    <span style='color:#3f7f59; '>//console.log('edict already loaded');</span>
    document.getElementById(<span style='color:#2a00ff; '>'loading-text'</span>).innerHTML = <span style='color:#2a00ff; '>''</span>;
}</code>

<p>Pretty easy and not worth explaining other than to point out that the callback function
receives an SQLTransaction and an SQLResultSet object respectively.</p>

<p>Let's get started on the error callback:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Callback for if checkDB() fails - ie. no "edict" table</span>
<span style='color:#3f7f59; '>//SO create it and fill it</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> errorCheckDB(transaction, error)
{    
    console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'edict table not exist - will create and fill'</span>);
    
    <span style='color:#3f7f59; '>//here we need to do something to fill the table</span>
}</code>


<p>This code so far will run without errors (but don't forget include <code class="file">websql_core.js</code> from <code class="file">index.html</code> (above the <code class="file">japxlate.js</code> include)) but won't do anything useful. It will get to the "edict table not exist - will create and fill"
log message and then stop. In the error callback, we need to run another transaction on the Japxlate
database which will load all the dictionary data we need. Change <code>errorCheckDB()</code> to look like this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Callback for if checkDB() fails - ie. no "edict" table</span>
<span style='color:#3f7f59; '>//SO create it and fill it</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> errorCheckDB(transaction, error)
{   
    console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'edict table not exist - will create and fill'</span>);
    
    <span style='color:#3f7f59; '>//version 1.0, 4 megabytes</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> db = window.openDatabase(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Japxlate</span><span style='color:#2a00ff; '>"</span>, <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>1.0</span><span style='color:#2a00ff; '>"</span>, <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Japxlate DB</span><span style='color:#2a00ff; '>"</span>, 4 * 1024 * 1024);
    
    db.transaction(populateDB, errorWebSQL, successPopulate);
}</code>

<p>We open the same Japxlate database and try to run the <code>populateDB()</code> queries on it. We have new
success and error callbacks. <code>populateDB()</code> looks like this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Create and fill the "edict" table</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> populateDB(tx)
{
    console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'creating and filling edict table'</span>);
    
    <span style='color:#3f7f59; '>//DROP if present (ie. because it's present but empty)</span>
    tx.executeSql(<span style='color:#2a00ff; '>'DROP TABLE IF EXISTS edict'</span>);
    
    <span style='color:#3f7f59; '>//create</span>
    tx.executeSql(<span style='color:#2a00ff; '>'CREATE TABLE IF NOT EXISTS edict(id unique, kanji, kana, definition)'</span>);
    
    websqlEdictInserts(tx); <span style='color:#3f7f59; '>//see websql_edict_inserts.js</span>
}</code>

<p>We create the table according to our schema - DROPing it first just in case and so the CREATE doesn't fail.
Finally we call <code>websqlEdictInserts()</code> which is a function we'll put in another JavaScript file. The <code>websqlEdictInserts()</code> function
accepts an SQLTransaction object and essentially runs a huge list of INSERT queries on it to populate our
table. This function isn't very <em>do-at-home</em>able because it's basically a dump of the most common words
from the <a href="https://twitter.com/japxlate">@japxlate</a> Twitter feed's database. If you are following this tutorial step by step, please
get the file <code class="file">/js/websql_edict_inserts.js</code> from the app's GitHub repository and stick it in your <code class="file">/assets/www/js</code> folder. To explain
it a little bit more, here's an excerpt from <code class="file">/js/websql_edict_inserts.js</code>:</p>

<code class="multiline"><span style='color:#7f0055; font-weight:bold; '>function</span> websqlEdictInserts(tx)
{
    tx.executeSql(<span style='color:#2a00ff; '>'INSERT INTO edict(id, kanji, kana, definition) VALUES(5,"咖哩","カレー","/curry/rice and curry/")'</span>);
    tx.executeSql(<span style='color:#2a00ff; '>'INSERT INTO edict(id, kanji, kana, definition) VALUES(21,"擤む","かむ","/to blow (one</span><span style='color:#2a00ff; '>\'</span><span style='color:#2a00ff; '>s nose)/")'</span>);
    tx.executeSql(<span style='color:#2a00ff; '>'INSERT INTO edict(id, kanji, kana, definition) VALUES(119,"１０００円","せんえん","/1000 yen/")'</span>);
    tx.executeSql(<span style='color:#2a00ff; '>'INSERT INTO edict(id, kanji, kana, definition) VALUES(138,"１割","いちわり","/ten percent/")'</span>);
    &vellip;
}</code>

<p>Note that the ID numbers aren't in sequence because these words are the most common 20,000 or so words
from <a href="https://twitter.com/japxlate">@japxlate</a>'s Edict dictionary which has nearly 200,000 entries!</p>

<p>OK, that's <code>populateDB()</code> in the bag. But don't forget <code>errorCheckDB()</code>'s custom error and success callbacks.
Let's do the error callback first:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Generic SQLError handler (for both db.transaction() and tx.executeSQL())</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> errorWebSQL(transactionOrError, errorOrNull)
{   
    <span style='color:#7f0055; font-weight:bold; '>var</span> error = <span style='color:#7f0055; font-weight:bold; '>null</span>;
    
    <span style='color:#7f0055; font-weight:bold; '>if</span>(<span style='color:#7f0055; font-weight:bold; '>typeof</span> transactionOrError == <span style='color:#2a00ff; '>'SQLTransaction'</span>) {    <span style='color:#3f7f59; '>//from tx.executeSQL()</span>
        error = errorOrNull;
    } <span style='color:#7f0055; font-weight:bold; '>else</span> {    <span style='color:#3f7f59; '>//from db.transaction()</span>
        error = transactionOrError;
    }
    
    console.<span style='color:#7f0055; font-weight:bold; '>log</span>(error); <span style='color:#3f7f59; '>//error is now an SQLError object</span>
    
    alert(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Error processing SQL: </span><span style='color:#2a00ff; '>"</span> + error.code);
}</code>

<p>Ouch! This looks a bit over-complicated. What's going on? Well, I didn't realise at first,
and I only discovered it on a hunch, but we can reference error callbacks from both
the database.transaction() and transaction.executeSQL() methods (as we are already doing) but <strong>in each case they will receive different parameters!</strong>.
The PhoneGap / Cordova docs for the Web SQL API - at the time of writing - don't seem to realise this
and actually are therefore incorrect.
<span class="new_3_3_0">(The PhoneGap v3.3.0 docs remove the entire Web SQL reference section.)</span>
This is something of a generic error callback and so we pull some strings to handle both cases.
Error callbacks as called from database.transaction() will receive (SQLError), and error callbacks
called from transaction.executeSQL() will receive (SQLTransaction, SQLError).
</p>

<p>We simply alert out the code property of the received SQLError object.
This is going to be our recyclable Web SQL error handler going forward with the app.</p>

<p>The success callback for <code>errorCheckDB()</code> is going to do the same as the success callback for <code>checkDB()</code>
(which is <code>successCheckDB()</code>):</p>

<code class="multiline"><span style='color:#3f7f59; '>//Callback for if errorCheckDB() succeeds - ie. "edict" table populated OK</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> successPopulate()
{
    console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'finished loading edict'</span>);
    document.getElementById(<span style='color:#2a00ff; '>'loading-text'</span>).innerHTML = <span style='color:#2a00ff; '>''</span>;
}</code>

<p>Include <code class="file">websql_edict_inserts.js</code> from <code class="file">index.html</code> (above the include for <code class="file">websql_core.js</code>) and we are ready to go for a spin!</p>

<p>On first run, the "database loading" message and spinner take a few seconds to disappear,
and the log messages indicate database loading success. It looks like this:</p>

<div class="figure">
    <img src="img/figure/fig_290.png">
    <p>Figure 29. First run of app with Web SQL database loading</p>
</div>

<p>Go ahead and run the app again after exiting it, the 2nd time around feels kind of faster right? Let's check the logs:</p>

<div class="figure">
    <img src="img/figure/fig_300.png">
    <p>Figure 30. Second, faster run of app with Web SQL database loading</p>
</div>

<p><strong>Woah!</strong> That's right, Web SQL databases that you've created <em>persist</em> over multiple sessions
of the app (or browser). Pretty hot and tasty! This is a great reason why Web SQL, as abandoned
and awkward as it is, is really useful for mobile WebView apps as it can be used for saving things
offline.</p>

<h3 id="the_search_tab_iii">Querying the database</h3>

<p>Right, so that's the database created, the table created, and the table filled. Phew!</p>

<p>We're coming to the meat and bones of it now which is getting results from the
database based on the user's search query. This will involve a bit of work on
the frontend interface and a <em>lot</em> of work on the backend. As we are kind of frazzled
with Web SQL things right now, let's get to work on the frontend interface first.</p>

<p>Let's make a new JavaScript file in <code class="file">/assets/www/js</code> called <code class="file">search_interface.js</code> to hold anything
to do with the frontend look and feel of searching. Right, one of the main things we'll want to do
is to put search results from the database into the container div in our markup. Let's add a 
function to do this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Put the matching search results (which could be zero matches) on the page</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> putResultsOnPage(results)
{
    <span style='color:#3f7f59; '>//get search results div</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> theDiv = document.getElementById(<span style='color:#2a00ff; '>'search-results'</span>);
    
    <span style='color:#3f7f59; '>//clear current content</span>
    theDiv.innerHTML = <span style='color:#2a00ff; '>''</span>;
    
    <span style='color:#3f7f59; '>//might be no matches</span>
    <span style='color:#7f0055; font-weight:bold; '>if</span>(results.rows.length === 0)
    {
        theDiv.innerHTML = <span style='color:#2a00ff; '>'No matches found in the common words dictionary.\</span>
<span style='color:#2a00ff; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;Tweet @japxlate yourAdvancedWord for advanced word definitions.'</span>;
        buttonSpinnerVisible(<span style='color:#7f0055; font-weight:bold; '>false</span>);    <span style='color:#3f7f59; '>//stop the loading spinner</span>
        <span style='color:#7f0055; font-weight:bold; '>return</span>;
    }
    
    <span style='color:#3f7f59; '>//some results so loop through and print</span>
    <span style='color:#7f0055; font-weight:bold; '>for</span>(<span style='color:#7f0055; font-weight:bold; '>var</span> loop = 0; loop &lt; results.rows.length; loop++)
    {
        <span style='color:#7f0055; font-weight:bold; '>var</span> <span style='color:#7f0055; font-weight:bold; '>item</span> = results.rows.<span style='color:#7f0055; font-weight:bold; '>item</span>(loop);
        
        <span style='color:#7f0055; font-weight:bold; '>var</span> var theRomaji = item.kana;    //TODO
        
        <span style='color:#7f0055; font-weight:bold; '>var</span> formattedDefinition = format_slashes(<span style='color:#7f0055; font-weight:bold; '>item</span>.definition);
        
        <span style='color:#7f0055; font-weight:bold; '>var</span> defText = <span style='color:#7f0055; font-weight:bold; '>item</span>.kanji + <span style='color:#2a00ff; '>' / '</span> + <span style='color:#7f0055; font-weight:bold; '>item</span>.kana + <span style='color:#2a00ff; '>' ('</span> + theRomaji + <span style='color:#2a00ff; '>') / '</span> + formattedDefinition;
        defText = defText.<span style='color:#7f0055; font-weight:bold; '>replace</span>(<span style='color:#7f0055; font-weight:bold; '>new</span> RegExp(global_searchTerm, <span style='color:#2a00ff; '>'ig'</span>), <span style='color:#2a00ff; '>'&lt;span style="color:#990000;">$&amp;&lt;/span>'</span>);
        
        <span style='color:#7f0055; font-weight:bold; '>var</span> defLine = <span style='color:#2a00ff; '>'&lt;img src="img/j.png" style="vertical-align:middle;"> '</span> + defText + <span style='color:#2a00ff; '>'&lt;hr>'</span>;
        <span style='color:#3f7f59; '>//var defLine = '&lt;p class="def-line"> ' + defText + '&lt;/p>'; //had CSS styling issues (mostly text overflow)</span>
        
        theDiv.innerHTML += defLine;
    }
    
    buttonSpinnerVisible(<span style='color:#7f0055; font-weight:bold; '>false</span>);    <span style='color:#3f7f59; '>//stop the loading spinner</span>
}</code>

<p>We'll expect to be passed an SQLResultSet object which will come from a successful query on our Web SQL
database.
First we reset the current (ie. old) results by setting the container div's innerHTML property
to empty.
We then cover a scenario of no matches by printing a "no matches" message (with a plug for the 
<a href="https://twitter.com/japxlate">@japxlate</a> Twitter bot!). Note that you can split up very long quoted strings in JavaScript
by ending lines with a '\'. We then stop the "searching" spinner by calling the <code>buttonSpinnerVisible()</code>
function with a parameter of false. We'll write this function shortly and it's basically a way
to switch the "searching" spinner on and off. We then return.</p>

<div class="sidenote">
<strong><code>document.getElementById('some-id')</code> versus <code>document.querySelector('#some-id')</code></strong>

<p>You may be wondering why, for single elements, I am using <code>document.getElementById('some-id')</code>
and not the new fangled <code>document.querySelector('#some-id')</code>. Well it's true that these
will both return the same element, and it's true that <code>getElementById()</code> is a much older
piece of XML DOM, but the issue - at the time of writing - is one of performance (and
perhaps <code>getElementById()</code> is a teeny tiny bit more readable). After some benchmarking experiments
in desktop Chrome (using the mega useful <code>console.time()</code> and <code>console.timeEnd()</code> as at <a href="https://developers.google.com/chrome-developer-tools/docs/console-api#consoletimelabel">https://developers.google.com/chrome-developer-tools/docs/console-api#consoletimelabel</a>) I saw that, for single elements, <code>getElementById()</code>
was much faster than <code>querySelector()</code>. Out of curiosity I also tested jQuery's <code>$('#some-id)</code> (which
returns a jQuery-specific list of nodes) and found this to be much slower than the browser's native
<code>querySelector()</code>. Of note is that the new jQuery v2.0 was much faster than v1.x for the same selector
(though still slower than <code>querySelector()</code>).
</div>

<p>Now, if we're still in the function we'll have <em>some</em> results. We loop over and retrieve the
results using the SQLResultSet object's <code>rows.length</code> property and <code>rows.item(itemIndex)</code> method.
What we do in the loop looks fiddly, but all we are doing is replicating the style of definition lines
that <a href="https://twitter.com/japxlate">@japxlate</a> uses. If you remember the snippet of <code class="file">websql_edict_inserts.js</code> that we looked at earlier,
the format of the "definition" field in the database is "/definition one/definition two/definition three/".
We want to space these multiple definitions out a bit more and remove the lead and tail slashes;
for that we'll use a helper function called <code>format_slashes()</code> which also goes in this file:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Clean up the EDICT definition line that we get from our Web SQL DB</span>
<span style='color:#3f7f59; '>//For example, "/one/two/three/" --> "one; two; three"</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> format_slashes(slashesString)
{
    <span style='color:#3f7f59; '>//remove leading and trailing '/' characters</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> string = slashesString.<span style='color:#7f0055; font-weight:bold; '>replace</span>(<span style='color:#2a00ff; '>/</span><span style='color:#2a00ff; '>^</span><span style='color:#2a00ff; '>\/</span><span style='color:#2a00ff; '>/</span>, <span style='color:#2a00ff; '>''</span>); <span style='color:#3f7f59; '>//leading</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> string = string.<span style='color:#7f0055; font-weight:bold; '>replace</span>(<span style='color:#2a00ff; '>/</span><span style='color:#2a00ff; '>\/</span><span style='color:#2a00ff; '>$</span><span style='color:#2a00ff; '>/</span>, <span style='color:#2a00ff; '>''</span>); <span style='color:#3f7f59; '>//trailing</span>
    
    <span style='color:#3f7f59; '>//change remaining '/' characters to a semicolon with space</span>
    <span style='color:#7f0055; font-weight:bold; '>return</span> string.<span style='color:#7f0055; font-weight:bold; '>replace</span>(<span style='color:#2a00ff; '>/</span><span style='color:#2a00ff; '>\/</span><span style='color:#2a00ff; '>/</span><span style='color:#7f0055; font-weight:bold; '>g</span>, <span style='color:#2a00ff; '>'; '</span>);
}</code>

<p>We use JavaScript's core <code>replace()</code> method to change the slashes based on regex matching.
We replace single lead and tail slashes with an empty string.
We replace globally (the 'g' modifier after the regex) all remaining slashes with a semicolon
followed by space. We return the modified string.</p>

<p>OK, let's come back to explaining <code>putResultsOnPage()</code>. 
We create in <code>defText</code> a nicely formatted definition line.
We use <code>String.replace()</code> on this definition line to highlight the user's search term in our
trademark red. For this we use <code>global_searchTerm</code> which we'll define a bit later on.
</p>

<p><code>buttonSpinnerVisible()</code> is a simple CSS style toggler that also goes in <code class="file">search_interface.js</code> and looks like this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Toggle for search button's loading spinner</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> buttonSpinnerVisible(visible)
{
    <span style='color:#7f0055; font-weight:bold; '>var</span> spinner = document.getElementById(<span style='color:#2a00ff; '>'button-spinner'</span>);
    
    <span style='color:#7f0055; font-weight:bold; '>if</span>(visible)
    {
        spinner.style.visibility = <span style='color:#2a00ff; '>'visible'</span>;
    }
    
    <span style='color:#7f0055; font-weight:bold; '>else</span>
    {
        spinner.style.visibility = <span style='color:#2a00ff; '>'hidden'</span>;
    }
}</code>

<p>Remember in <code class="file">websql_core.js</code> we did this a couple of times:</p>

<code class="multiline">document.getElementById('loading-text').innerHTML = '';</code>

<p>As this is manipulating the search interface, let's refactor this as a function in <code class="file">search_interface.js</code>.
Let's call it <code>clearLoadingMessage()</code>:</p>

<code class="multiline"><span style='color:#7f0055; font-weight:bold; '>function</span> clearLoadingMessage()
{
    document.getElementById(<span style='color:#2a00ff; '>'loading-text'</span>).innerHTML = <span style='color:#2a00ff; '>''</span>;
}</code>

<p>Then replace the two <code>document.getElementById('loading-text').innerHTML = '';</code> lines in <code class="file">websql_core.js</code>
with calls to <code>clearLoadingMessage();</code>.</p>

<p>OK, in <code class="file">search_interface.js</code> we now have all of the functions that <em>other functions</em> might call
to update the interface for database searching, but we are missing something here. The user! We need to catch
tap events on the Search button and then use their entered query to search the database and return results.
Let's start where the user starts - the Search button. Let's add a click handler. Add a call to:</p>

<code class="multiline">configureSearchButton();</code>

<p>at the bottom of <code>receivedEvent()</code> in good old <code class="file">index.js</code>.</p>

<p>We define <code>configureSearchButton()</code> in <code class="file">search_interface.js</code>:</p>

<code class="multiline"><span style='color:#3f7f59; '>//search button clickability</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> configureSearchButton()
{
    document.getElementById(<span style='color:#2a00ff; '>'search-button'</span>).addEventListener(<span style='color:#2a00ff; '>'click'</span>, onclickForSearchButton, <span style='color:#7f0055; font-weight:bold; '>false</span>);
}</code>

<p>We define <code>onclickForSearchButton()</code> as the click handler for the search button. <code>onclickForSearchButton()</code>, also in <code class="file">search_interface.js</code>, is
like this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Perform a dictionary search for entered query</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> onclickForSearchButton(event)
{
    <span style='color:#7f0055; font-weight:bold; '>var</span> q = document.getElementById(<span style='color:#2a00ff; '>'search-query'</span>).value;
    
    <span style='color:#3f7f59; '>//some kanji searches are going to be legitimately only one char</span>
    <span style='color:#7f0055; font-weight:bold; '>if</span>(q.length &lt; 1)
    {
        <span style='color:#7f0055; font-weight:bold; '>return</span>;
    }
    
    buttonSpinnerVisible(<span style='color:#7f0055; font-weight:bold; '>true</span>);
    
    <span style='color:#7f0055; font-weight:bold; '>var</span> matches = doEdictQueryOn(q);
}</code>

<p>We get the user's entered search query and - on the condition that it's at least one character long - we pass
it to <code>doEdictQueryOn()</code> after displaying the "searching" spinner.
<code>doEdictQueryOn()</code> is a function that we haven't written yet that will need a whole 'nother JavaScript
file. We've already got quite a few JavaScript files, but this is keeping it nice and modular.
Create <code class="file">websql_query.js</code> in <code class="file">/assets/www/js</code> and add <code>doEdictQueryOn()</code> thus:</p>

<code class="multiline"><span style='color:#3f7f59; '>//function to query the database based on whatever query string</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> doEdictQueryOn(newQ)
{
    <span style='color:#3f7f59; '>//TODO</span>
}</code>

<p>What? It's empty! Yes, we're going to take a breather now and plan what we're going to do next.
A keyboard break if you like.
Remember back in the <a href="#the_search_tab_i">Layout and interface</a> section of this chapter when we laid down some rules about our app?
It's time to recap those now as it will affect how we implement dictionary searching.
We said we'll stick to a rule "that the user's search query can be in Japanese as well as English".
Obviously we'll then go down different search query routes depending on the entered language.
So we need a way to detect if the query is Japanese or English.</p>

<div class="sidenote">
<strong>Why two search querying routes?</strong>
<p>We could get away with not detecting the input query's language  and having this kind of logic:</p>
    <p>"Assume the query is English, do a search, if no results then assume it's Japanese and search again"</p>
<p>Which has two problems. We have to make an assumption about how our app is being <em>mostly</em> used.
(Admittedly we could change the assumption if we find out it's wrong.)
Another problem is performance - we may be searching unnecessarily.</p>
</div>

<p>A very simple, and linguistically incorrect!, way to do this is to see if we have
multibyte characters in our query string or not.
We've set our HTML page to be UTF-8. UTF-8 is interesting because it's a flavour of Unicode
that's backwards compatible with good ol' ASCII. ASCII can be utf-8, but so can Japanese!
But ASCII won't set the right bits in each byte to be considered a multibyte stream.
Something we can use to our advantage is that for ASCII, the length of a string in bytes
will also be the length of that string in <em>characters</em>. For multibyte utf-8 strings,
this will not be the case and the byte length will be <strong>greater than</strong> the character length.</p>

<p>Let's implement an <code>is_mb()</code> ("mb" meaning "multibyte") check using this knowledge.
Keeping things modular, and realising that we are going to need functions soon for
Japanese language handling, make a new file in <code class="file">/assets/www/js</code> called <code class="file">linguistics.js</code>. Add
<code>is_mb()</code> thus:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Does the given utf8 string have multibyte characters or not?</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> is_mb(utf8String)
{
    <span style='color:#7f0055; font-weight:bold; '>return</span> utf8String.length != mb_bytelen(utf8String);
}</code>

<p>Here we compare a string's length in characters (using the <code>length</code> property
- JavaScript operates internally with utf-16 unicode) with its length in bytes.
<code>mb_bytelen()</code> is the key function here that we need to write. It will give us the
<em>byte</em> length for a utf8 string. Put it also in <code class="file">linguistics.js</code>:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Get length in BYTES of a utf8 string</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> mb_bytelen(utf8String)
{
    <span style='color:#3f7f59; '>//Matches only the 10.. bytes that are non-initial characters</span>
    <span style='color:#3f7f59; '>//in a multi-byte sequence.</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> m = encodeURIComponent(utf8String).<span style='color:#7f0055; font-weight:bold; '>match</span>(<span style='color:#2a00ff; '>/</span><span style='color:#2a00ff; '>%</span><span style='color:#2a00ff; '>[</span><span style='color:#2a00ff; '>89ABab</span><span style='color:#2a00ff; '>]</span><span style='color:#2a00ff; '>/</span><span style='color:#7f0055; font-weight:bold; '>g</span>);
    <span style='color:#7f0055; font-weight:bold; '>return</span> utf8String.length + (m ? m.length : 0);
}</code>

<p>In utf-8, everything is a sequence of bytes. For an ASCII character, one byte is the full sequence -
that byte <em>is</em> the character. But it allows for multibyte characters by the initial byte
in that character's sequence of bytes setting a special bit. This special bit tells
the browser (or programming language or text editor etc) that "there's more to come!"
and the browser adds the remaining bytes in the sequence to get the full value for that character.
The remaning bytes also set a special bit so the browser knows when that particular
character has all of its bytes read. For the gory details please see <a href="http://en.wikipedia.org/wiki/UTF-8">http://en.wikipedia.org/wiki/UTF-8</a>.
</p>

<p>So what we are doing in <code>mb_bytelen()</code> is adding the length of the string in characters
to the count of non-initial character sequence bytes. This will give us the total byte length
for any utf8 string - containing multibyte characters or not!</p>

<p>OK, <code>is_mb()</code> is one important tool for our database querying logic in the bag.
Using it, let's think more about our query logic with some pseudocode:</p>

<code class="multiline"><span style='color:#7f0055; font-weight:bold; '>if</span>(is_mb(searchTerm)) {
    <span style='color:#3f7f59; '>//searchTerm is Japanese (or at least multibyte)</span>
    <span style='color:#3f7f59; '>//</span>
    <span style='color:#3f7f59; '>//[1] exact kanji match</span>
    <span style='color:#3f7f59; '>//[2] exact kana match</span>
} <span style='color:#7f0055; font-weight:bold; '>else</span> {
    <span style='color:#3f7f59; '>//searchTerm is English or, as last resort, romaji</span>
    <span style='color:#3f7f59; '>//</span>
    <span style='color:#3f7f59; '>//[1] exact definition match</span>
    <span style='color:#3f7f59; '>//[2] partial definition match</span>
    <span style='color:#3f7f59; '>//[3] exact romaji match (on kana field)</span>
}</code>

<p>So, if we detect multibyte characters in the search term, we <em>assume</em> it is Japanese and try to match it exactly
against, first, the kanji field of the words in our database. Then, if that produces no results,
we try to match it exactly against the kana field. This priority order is realistic because
kanji (Chinese idiogrammic characters) are the "correct" way to write a Japanese word. The kana
is just the way to pronounce those Chinese characters. Though note that some words are kana only and
don't hava a kanji.</p>

<p>We assume that the search term is in English if it contains no multibyte characters. Then we focus
on the definition field of our database. Remember that definition entries look like this:</p>

<code class="multiline">"/uncertain/vague/ambiguous/"</code>

<p>Multiple definitions are separated by slashes. So our most relevant results (query [1] of the English route) would
be to find the search term <strong>exactly</strong> as one of these definitions. A search for "vague" would
match the above definition, for example. If that produces no results,
we query for <em>partial</em> matches of the search term in these definitions. For example a search for
"director" will match a definition of <code>"/company director/board member/"</code>.
Finally, if we still have no results, we can take a gamble and assume that the user has entered
a term in romaji (which is Japanese written in abc like "sayonara" or "moshimoshi").
For this we'll have to convert the search term into phonetic kana and query for a matching kana
field. So this one needs a bit more work programmatically.</p>

<p>Note that if we go down the Japanese route, and get no results at the end, we <em>don't</em> then proceed
down the English route (and vice-versa).</p>

<p>Let's implement the Japanese route first as the queries are easier. We'll go back to working in
<code class="file">websql_search.sql</code>.
Remember from writing <code class="file">websql_core.js</code> how Web SQL works with callback chains?
Well, with this in mind (and don't get me wrong, there are better and cleverer ways to do this)
we're going to stick a couple of global variables at the top of <code class="file">websql_search.sql</code>
so that all callback functions can access them:</p>

<code class="multiline"><span style='color:#3f7f59; '>//User's search term as a global variable (so we can access it from all the different callbacks). Hmmm...</span>
<span style='color:#7f0055; font-weight:bold; '>var</span> global_searchTerm = <span style='color:#7f0055; font-weight:bold; '>null</span>;

<span style='color:#3f7f59; '>//Maximum number of search results to return for any query</span>
<span style='color:#7f0055; font-weight:bold; '>var</span> global_maxResultsCount = 40;</code>

<p>Now make <code>doEdictQueryOn()</code> look like this:</p>

<code class="multiline"><span style='color:#7f0055; font-weight:bold; '>function</span> doEdictQueryOn(newQ)
{
    <span style='color:#3f7f59; '>//set global_searchTerm</span>
    global_searchTerm = newQ;
    
    <span style='color:#3f7f59; '>//version 1.0, 4 megabytes</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> db = window.openDatabase(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Japxlate</span><span style='color:#2a00ff; '>"</span>, <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>1.0</span><span style='color:#2a00ff; '>"</span>, <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Japxlate DB</span><span style='color:#2a00ff; '>"</span>, 4 * 1024 * 1024);
    
    <span style='color:#7f0055; font-weight:bold; '>if</span>(is_mb(global_searchTerm))    <span style='color:#3f7f59; '>//Japanese (or at least multibyte)</span>
    {
        <span style='color:#3f7f59; '>//console.log('doing as japanese - kanji');</span>
        db.transaction(queryDB_ja, errorWebSQL);
    }
    
    <span style='color:#7f0055; font-weight:bold; '>else</span>       <span style='color:#3f7f59; '>//ie. English (or - as last resort - romaji)</span>
    {
        <span style='color:#3f7f59; '>console.log('doing as english - exact');</span>
    }
}</code>

<p>We simply save the search term into <code>global_searchTerm</code>, open the database and attempt the
<code>queryDB_ja()</code> query function (using our generic Web SQL error handler). We'll come back to the
<code>else</code> section for English later, but in the meantime let's make <code>queryDB_ja()</code> which is like this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Search edict for an exact kanji match</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> queryDB_ja(tx)
{
    <span style='color:#7f0055; font-weight:bold; '>var</span> safeQ = global_searchTerm;
    
    <span style='color:#3f7f59; '>//use placeholders (so we don't need to escape the query)</span>
    tx.executeSql(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>SELECT * FROM edict WHERE kanji = ? LIMIT </span><span style='color:#2a00ff; '>"</span> + global_maxResultsCount, [safeQ], successQueryDB_ja, errorWebSQL);
}</code>

<p>We accept an SQLTransaction object - as per the Web SQL specification - and call it tx for short.
We use <code>tx.executeSql()</code> to run a very simple SQL query on the edict table; Matching
the kanji field exactly to the search term. Note how we get the search term from the
global variable we defined earlier.</p>
<p>In the SQL query, we have <code>"kanji = ?"</code>, the question mark is a placeholder for parameter (or value)
binding. We then specify the value to be bound to this placeholder in the 2nd argument to <code>tx.executeSql()</code>,
in this case safeQ.
Why do this? Why not just query for <code>"kanji = '" + safeQ + "'"</code>, ie. literally.
Well because, this way, if the entered search term contains single quotes or slashes
or anything that Web SQL considers "special", the SQL query will break and result in errors.
When we use parameter binding, Web SQL is going to <em>escape</em> the parameter value for us
so that we are safe from dodgy characters accidentally breaking our SQL (or malicious
"SQL injection" attacks). 
You can try this a little later if you like to see how wrong it can go!</p>

<p>So we query with a success callback of <code>successQueryDB_ja()</code> and our all-purpose error
handler. Note that <code>successQueryDB_ja()</code> will be called if the <code>executeSql()</code> query is
valid and executes - which means even if zero results are returned.
So <code>successQueryDB_ja()</code> is going to look like this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Callback for if queryDB_ja() did not error (which includes zero results)</span>
<span style='color:#3f7f59; '>//Print kanji matches if we have any ELSE try kana matches</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> successQueryDB_ja(tx, results)
{
    <span style='color:#7f0055; font-weight:bold; '>if</span>(results.rows.length == 0)    <span style='color:#3f7f59; '>//no kanji matches - try kana matches</span>
    {
        <span style='color:#3f7f59; '>//console.log('no ja kanji matches');</span>

        <span style='color:#3f7f59; '>//version 1.0, 4 megabytes</span>
        <span style='color:#7f0055; font-weight:bold; '>var</span> db = window.openDatabase(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Japxlate</span><span style='color:#2a00ff; '>"</span>, <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>1.0</span><span style='color:#2a00ff; '>"</span>, <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Japxlate DB</span><span style='color:#2a00ff; '>"</span>, 4 * 1024 * 1024);

        db.transaction(queryDB_ja_kana, errorWebSQL);
    }
   
    <span style='color:#7f0055; font-weight:bold; '>else</span>
    {
        putResultsOnPage(results);
    } 
}</code>

<p>We receive the SQLTransaction and an SQLResultSet.
We check the <code>rows.length</code> property of the resultset to see if we got any matches or not.
If we have no matches then we open the DB again and run a different query function on it,
namely <code>queryDB_ja_kana()</code> which is going to search for kana matches against
the search term.
If we have any matches, we simply call our <code>putResultsOnPage()</code> function
(that we made previously in <code class="file">search_interface.js</code>) and pass it the resultset. Then
we are done with this particular query route.
OK, we still need to implement <code>queryDB_ja_kana()</code>, which - yes you've guessed it -
is almost identical to <code>queryDB_ja()</code> but using the kana field:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Search edict for an exact kana match</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> queryDB_ja_kana(tx)
{
    <span style='color:#7f0055; font-weight:bold; '>var</span> safeQ = global_searchTerm;
    
    <span style='color:#3f7f59; '>//use placeholders (so we don't need to escape the query)</span>
    tx.executeSql(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>SELECT * FROM edict WHERE kana = ? LIMIT </span><span style='color:#2a00ff; '>"</span> + global_maxResultsCount, [safeQ], successQueryDB_ja_kana, errorWebSQL);
}</code>

<p>Nothing new here apart from the use of the kana field for searching. Oh and the
success callback of <code>successQueryDB_ja_kana()</code> which, as this is the last step of
our Japanese querying route, is going to be quite simple:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Callback for if queryDB_ja_kana() did not error (which includes zero results)</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> successQueryDB_ja_kana(tx, results)
{
    putResultsOnPage(results);
}</code>

<p>We simply print out any and all results that we might have.</p>

<p>We are now ready to give this Japanese query route a test drive! First,
include the new JavaScript files we've made at the bottom of <code class="file">index.html</code>
so that it looks like this:</p>

<code class="multiline">&vellip;
&lt;script type=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>text/javascript</span><span style='color:#2a00ff; '>"</span> src=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>js/linguistics.js</span><span style='color:#2a00ff; '>"</span>>&lt;/script>
&lt;script type=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>text/javascript</span><span style='color:#2a00ff; '>"</span> src=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>js/search_interface.js</span><span style='color:#2a00ff; '>"</span>>&lt;/script>
&lt;script type=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>text/javascript</span><span style='color:#2a00ff; '>"</span> src=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>js/websql_edict_inserts.js</span><span style='color:#2a00ff; '>"</span>>&lt;/script>
&lt;script type=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>text/javascript</span><span style='color:#2a00ff; '>"</span> src=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>js/websql_core.js</span><span style='color:#2a00ff; '>"</span>>&lt;/script>
&lt;script type=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>text/javascript</span><span style='color:#2a00ff; '>"</span> src=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>js/websql_search.js</span><span style='color:#2a00ff; '>"</span>>&lt;/script>
&lt;script type=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>text/javascript</span><span style='color:#2a00ff; '>"</span> src=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>js/japxlate.js</span><span style='color:#2a00ff; '>"</span>>&lt;/script>
&lt;script type=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>text/javascript</span><span style='color:#2a00ff; '>"</span> src=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>js/index.js</span><span style='color:#2a00ff; '>"</span>>&lt;/script>
&lt;script type=<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>text/javascript</span><span style='color:#2a00ff; '>"</span>>
    app.initialize();
&lt;/script>
&vellip;</code>

<p>Run it! Enter an English search term and click the search button.
You'll get a console message of "doing as english - exact", and the
spinner will start to spin and not stop! We've obviously not finished the English
query route yet.</p>
<p>Let's check if it is really searching for any entered Japanese terms.
Go ahead and copy some random text from <a href="http://www.yahoo.co.jp">http://www.yahoo.co.jp</a> and paste
it into our app's search box. Click search. You'll probably
get the "no matches found" message (unless you got really lucky!).
OK, so that's working. What about an actual match? Open up the <code class="file">websql_edict_inserts.js</code>
file and copy any kanji or kana INSERT value. Search for this on the app
and you should get the corresponding definition. Nice!</p>

<p>This is pretty awesome right now. It's beginning to feel like a useful, working app!
OK, before the very final thing we need to implement for searching (I'll let
you guess what you think it is ;-)) let's tackle that English searching route.
Go back to the <code>else</code> clause in <code>doEdictQueryOn()</code> (in <code class="file">websql_search.js</code>) and edit it to
actually do something:</p>

<code class="multiline">&vellip;
<span style='color:#7f0055; font-weight:bold; '>if</span>(is_mb(global_searchTerm))    <span style='color:#3f7f59; '>//Japanese (or at least multibyte)</span>
{
    <span style='color:#3f7f59; '>//console.log('doing as japanese - kanji');</span>
    db.transaction(queryDB_ja, errorWebSQL);
}

<span style='color:#7f0055; font-weight:bold; '>else</span>       <span style='color:#3f7f59; '>//ie. English (or - as last resort - romaji)</span>
{
    console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'doing as english - exact'</span>);
    db.transaction(queryDB_en, errorWebSQL);
}
&vellip;</code>

<p>We do what we do for Japanese just with a different query function called <code>queryDB_en()</code>
which is going to do step [1] of our English route and is like this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Search edict for an exact English match</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> queryDB_en(tx)
{
    <span style='color:#7f0055; font-weight:bold; '>var</span> safeQ = global_searchTerm;
    
    <span style='color:#3f7f59; '>//use placeholders (so we don't need to escape the query)</span>
    tx.executeSql(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>SELECT * FROM edict WHERE definition LIKE ? LIMIT </span><span style='color:#2a00ff; '>"</span> + global_maxResultsCount, [<span style='color:#2a00ff; '>'%/'</span> + safeQ + <span style='color:#2a00ff; '>'/%'</span>], successQueryDB_en, errorWebSQL);
}</code>

<p>Here we query the definition field of our edict table and note how we use the LIKE
operator and not, as with the Japanese route queries, the '=' operator.
LIKE allows us to use wildcard characters which allows us to do a fuzzier search.
We need that functionality here as we are trying to match only one of
each database row's many definitions (separated by '/').</p>
<p>What's going on with our 2nd argument where we have to specify the value
for parameter binding?
Well, we basically build a LIKE condition that will match, completely, safeQ as ANY one
of the definition entries - first one, last one or any of the middle ones.
'%' is the SQL wildcard meaning "match anything" and actually it will match zero
characters if applicable too! With a definition of:</p>

<code class="multiline">"/one/two/three/"</code>

<p>then the same format of condition like: '%/one/%', '%/two/%', '%/three/%'
will match each corresponding definition respectively. We simply build this pattern and
put it in the 2nd argument.
We use the general error handler again and the success handler is <code>successQueryDB_en():</code></p>

<code class="multiline"><span style='color:#3f7f59; '>//Callback for if queryDB_en() did not error (which includes zero results)</span>
<span style='color:#3f7f59; '>//Print exact matches if we have any ELSE try partial matches</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> successQueryDB_en(tx, results)
{
    <span style='color:#7f0055; font-weight:bold; '>if</span>(results.rows.length == 0)    <span style='color:#3f7f59; '>//no exact matches - try partial matches</span>
    {
        <span style='color:#3f7f59; '>//console.log('no en exact matches');</span>
        
        <span style='color:#3f7f59; '>//version 1.0, 4 megabytes</span>
        <span style='color:#7f0055; font-weight:bold; '>var</span> db = window.openDatabase(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Japxlate</span><span style='color:#2a00ff; '>"</span>, <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>1.0</span><span style='color:#2a00ff; '>"</span>, <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Japxlate DB</span><span style='color:#2a00ff; '>"</span>, 4 * 1024 * 1024);
    
        db.transaction(queryDB_en_partial, errorWebSQL);
    }
   
    <span style='color:#7f0055; font-weight:bold; '>else</span>
    {
        putResultsOnPage(results);
    } 
}</code>

<p>This is cut from the same mould as <code>successQueryDB_en()</code> that we've just done.
If we have no results from exact matching, we move on to step [2] which is
partial matches by calling <code>queryDB_en_partial()</code>:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Search edict for a partial English match</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> queryDB_en_partial(tx)
{
    <span style='color:#7f0055; font-weight:bold; '>var</span> safeQ = global_searchTerm;
    
    <span style='color:#3f7f59; '>//use placeholders (so we don't need to escape the query)</span>
    tx.executeSql(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>SELECT * FROM edict WHERE definition LIKE ? LIMIT </span><span style='color:#2a00ff; '>"</span> + global_maxResultsCount, [<span style='color:#2a00ff; '>'%'</span> + safeQ + <span style='color:#2a00ff; '>'%'</span>], successQueryDB_en_partial, errorWebSQL);
}</code>

<p>This is very very similar to <code>queryDB_en()</code>, but the important difference is in
the LIKE condition. We do not use slashes here which means we are not
locked down to an exact match and will match any definition list
where the user's search term <em>appears</em>. For example, searching for "user
interface" will match a definiton of:</p>

<code class="multiline">"/graphical user interface/GUI/"</code>

<p>The success callback here is <code>successQueryDB_en_partial()</code> which is
going to trigger the final step [3] of English searching, or display
results from this step [2].</p>

<p>It is in the same shape as the other success callbacks so far:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Callback for if queryDB_en_partial() did not error (which includes zero results)</span>
<span style='color:#3f7f59; '>//Print partial matches if we have any ELSE try romaji matches</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> successQueryDB_en_partial(tx, results)
{
    <span style='color:#7f0055; font-weight:bold; '>if</span>(results.rows.length == 0)    <span style='color:#3f7f59; '>//no partial matches - try as romaji</span>
    {
        <span style='color:#3f7f59; '>//console.log('no en partial matches');</span>
             
        <span style='color:#3f7f59; '>//version 1.0, 4 megabytes</span>
        <span style='color:#7f0055; font-weight:bold; '>var</span> db = window.openDatabase(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Japxlate</span><span style='color:#2a00ff; '>"</span>, <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>1.0</span><span style='color:#2a00ff; '>"</span>, <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>Japxlate DB</span><span style='color:#2a00ff; '>"</span>, 4 * 1024 * 1024);
    
        db.transaction(queryDB_en_romaji, errorWebSQL);
    }
    
    <span style='color:#7f0055; font-weight:bold; '>else</span>
    {
        putResultsOnPage(results);
    } 
}</code>

<p>We do step [3] - if we need to - by calling <code>queryDB_en_romaji()</code>.
This is going to be the fiddly step that we mentioned earlier as it will need
to convert search terms like "sayonara" or "moshimoshi" into phonetic Japanese
kana so we can then search the database. <code>queryDB_en_romaji()</code> is like this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Search edict for a romaji match</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> queryDB_en_romaji(tx)
{
    <span style='color:#7f0055; font-weight:bold; '>var</span> safeQ = global_searchTerm;
    <span style='color:#7f0055; font-weight:bold; '>var</span> safeQKana = romaji_to_hira(global_searchTerm);
    
    <span style='color:#3f7f59; '>//use placeholders (so we don't need to escape the query)</span>
    tx.executeSql(<span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>SELECT * FROM edict WHERE kana LIKE ? LIMIT </span><span style='color:#2a00ff; '>"</span> + global_maxResultsCount, [safeQKana], successQueryDB_en_romaji, errorWebSQL);
}</code>

<p>We convert the search term into hiragana (which is <em>one</em> of the Japanese
phonetic scripts and the most common one used in the kana field of our table) via <code>romaji_to_hira()</code> which
we implement very soon.
The query is straightforward, but don't forget to implement the success callback of 
<code>successQueryDB_en_romaji()</code> which is a carbon copy of <code>successQueryDB_ja_kana()</code>
but with a different name.</p>

<p>So we've come to a bit of a dead-end as we need to implement the <code>romaji_to_hira()</code>
script conversion function.
Well, I know from the experience of building the <a href="https://twitter.com/japxlate">@japxlate</a> bot - and <a href="http://mapanese.info">Mapanese</a> -
that we can cover <strong>almost all</strong> cases of Japanese <--> English script conversion
by simple string replacement operations. For example, we have a table of all
Japanese characters and then a corresponding table of English spellings
for those characters. Then we can convert Japanese script to English and vice versa.</p>

<p>JavaScript has a builtin <code>String.replace()</code> method, but it works by replacing
the first (or all) matching regexes in the string with the supplied replacement value.
We can't give it a list of targets and a list of corresponding replacements.
We want something a little easier to use, and so we're going to go deep down and dirty
with some advanced JavaScript. We are going to <em>prototype</em> a new method onto the
String object which means we can add a new method to the String class ONCE and
it is available to any variable of type string in JavaScript!
Let's put this in <code class="file">linguistics.js</code> (we'll get back to database querying when we've
got the language conversion all done and dusted). OK, code first explanations second:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Here we use prototyping to add a method to the String class to give</span>
<span style='color:#3f7f59; '>//us the equivalent of PHP's str_replace()</span>
String.prototype.str_replace = <span style='color:#7f0055; font-weight:bold; '>function</span>(find, <span style='color:#7f0055; font-weight:bold; '>replace</span>)
{
    <span style='color:#7f0055; font-weight:bold; '>var</span> replaceString = <span style='color:#7f0055; font-weight:bold; '>this</span>;
    <span style='color:#7f0055; font-weight:bold; '>var</span> regex;
    
    <span style='color:#7f0055; font-weight:bold; '>for</span> (<span style='color:#7f0055; font-weight:bold; '>var</span> i = 0; i &lt; find.length; i++) {
        regex = <span style='color:#7f0055; font-weight:bold; '>new</span> RegExp(find[i], <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>g</span><span style='color:#2a00ff; '>"</span>);
        replaceString = replaceString.<span style='color:#7f0055; font-weight:bold; '>replace</span>(regex, <span style='color:#7f0055; font-weight:bold; '>replace</span>[i]);
    }
    
    <span style='color:#7f0055; font-weight:bold; '>return</span> replaceString;
};</code>

<p>'String' is JavaScript's object name for character strings. Any variable - or literal -
that's a string will be of object type 'String'. That's how we can run <code>.replace()</code> 
and <code>.match()</code> and things like that on any JavaScript string - because they are all String
objects and the String object has prototypes of those methods.</p>

<p>So the syntax to prototype a new method into the String object is:</p>

<code class="multiline">String.prototype.newMethodName = function(any, args, you, need){code; to; do; stuff;};</code>


<p>We name the method "str_replace" (in honour of PHP ;-)) and define it as a function
accepting two parameters; find and replace - both of which are character arrays.</p>

<p>In a prototype method, the context of 'this' will refer to the object on which the method was called.
For example, if calling <code>myStringVariable.str_replace()</code>, then in the <code>str_replace()</code> protoype,
'this' will be myStringVariable.</p>

<p>We save the string in <code>replaceString</code>. We then loop over each item in the find array
and <strong>globally</strong> (the 'g' modifier) replace any occurrences of it with the corresponding character
in the replace array. So yes, the find and replace arrays need to have the same number of
items in them which we don't explicitly police here.</p>

<p>Before we write <code>romaji_to_hira()</code>, we need the character tables that our <code>String.str_replace()</code>
will operate on. I won't dwell on these too much, and it's best to simply paste these
in to your code as a black box - this isn't a linguistics course! Though the variable
names and comments will help if you want to read through it. Stick these at the top of <code class="file">linguistics.js</code>:</p>

<code class="multiline"><span style='color:#3f7f59; '>//----character tables----------------------------------------------------------</span>

<span style='color:#3f7f59; '>//All single character hiragana (in "biggest" first order)</span>
<span style='color:#7f0055; font-weight:bold; '>var</span> coreHiragana =
[
    <span style='color:#2a00ff; '>'が'</span>, <span style='color:#2a00ff; '>'ぎ'</span>, <span style='color:#2a00ff; '>'ぐ'</span>, <span style='color:#2a00ff; '>'げ'</span>, <span style='color:#2a00ff; '>'ご'</span>,
    <span style='color:#2a00ff; '>'ざ'</span>, <span style='color:#2a00ff; '>'じ'</span>, <span style='color:#2a00ff; '>'ず'</span>, <span style='color:#2a00ff; '>'ぜ'</span>, <span style='color:#2a00ff; '>'ぞ'</span>,
    <span style='color:#2a00ff; '>'だ'</span>, <span style='color:#2a00ff; '>'ぢ'</span>, <span style='color:#2a00ff; '>'づ'</span>, <span style='color:#2a00ff; '>'で'</span>, <span style='color:#2a00ff; '>'ど'</span>,
    <span style='color:#2a00ff; '>'ば'</span>, <span style='color:#2a00ff; '>'び'</span>, <span style='color:#2a00ff; '>'ぶ'</span>, <span style='color:#2a00ff; '>'べ'</span>, <span style='color:#2a00ff; '>'ぼ'</span>,
    <span style='color:#2a00ff; '>'ぱ'</span>, <span style='color:#2a00ff; '>'ぴ'</span>, <span style='color:#2a00ff; '>'ぷ'</span>, <span style='color:#2a00ff; '>'ぺ'</span>, <span style='color:#2a00ff; '>'ぽ'</span>,
    <span style='color:#2a00ff; '>'か'</span>, <span style='color:#2a00ff; '>'き'</span>, <span style='color:#2a00ff; '>'く'</span>, <span style='color:#2a00ff; '>'け'</span>, <span style='color:#2a00ff; '>'こ'</span>,
    <span style='color:#2a00ff; '>'さ'</span>, <span style='color:#2a00ff; '>'し'</span>, <span style='color:#2a00ff; '>'す'</span>, <span style='color:#2a00ff; '>'せ'</span>, <span style='color:#2a00ff; '>'そ'</span>,
    <span style='color:#2a00ff; '>'た'</span>, <span style='color:#2a00ff; '>'ち'</span>, <span style='color:#2a00ff; '>'つ'</span>, <span style='color:#2a00ff; '>'て'</span>, <span style='color:#2a00ff; '>'と'</span>,
    <span style='color:#2a00ff; '>'な'</span>, <span style='color:#2a00ff; '>'に'</span>, <span style='color:#2a00ff; '>'ぬ'</span>, <span style='color:#2a00ff; '>'ね'</span>, <span style='color:#2a00ff; '>'の'</span>,
    <span style='color:#2a00ff; '>'は'</span>, <span style='color:#2a00ff; '>'ひ'</span>, <span style='color:#2a00ff; '>'ふ'</span>, <span style='color:#2a00ff; '>'へ'</span>, <span style='color:#2a00ff; '>'ほ'</span>,
    <span style='color:#2a00ff; '>'ま'</span>, <span style='color:#2a00ff; '>'み'</span>, <span style='color:#2a00ff; '>'む'</span>, <span style='color:#2a00ff; '>'め'</span>, <span style='color:#2a00ff; '>'も'</span>,
    <span style='color:#2a00ff; '>'や'</span>,       <span style='color:#2a00ff; '>'ゆ'</span>,       <span style='color:#2a00ff; '>'よ'</span>,
    <span style='color:#2a00ff; '>'ら'</span>, <span style='color:#2a00ff; '>'り'</span>, <span style='color:#2a00ff; '>'る'</span>, <span style='color:#2a00ff; '>'れ'</span>, <span style='color:#2a00ff; '>'ろ'</span>,
    <span style='color:#2a00ff; '>'わ'</span>, <span style='color:#2a00ff; '>'ゐ'</span>,       <span style='color:#2a00ff; '>'ゑ'</span>, <span style='color:#2a00ff; '>'を'</span>,
    <span style='color:#2a00ff; '>'ん'</span>, <span style='color:#2a00ff; '>'っ'</span>,
    <span style='color:#2a00ff; '>'あ'</span>, <span style='color:#2a00ff; '>'い'</span>, <span style='color:#2a00ff; '>'う'</span>, <span style='color:#2a00ff; '>'え'</span>, <span style='color:#2a00ff; '>'お'</span>,
    <span style='color:#2a00ff; '>'ゃ'</span>,       <span style='color:#2a00ff; '>'ゅ'</span>,       <span style='color:#2a00ff; '>'ょ'</span>,
    <span style='color:#2a00ff; '>'ぁ'</span>, <span style='color:#2a00ff; '>'ぃ'</span>, <span style='color:#2a00ff; '>'ぅ'</span>, <span style='color:#2a00ff; '>'ぇ'</span>, <span style='color:#2a00ff; '>'ぉ'</span>,
];

<span style='color:#3f7f59; '>//All single character katakana (in "biggest" first order)</span>
<span style='color:#7f0055; font-weight:bold; '>var</span> coreKatakana =
[
    <span style='color:#2a00ff; '>'ガ'</span>, <span style='color:#2a00ff; '>'ギ'</span>, <span style='color:#2a00ff; '>'グ'</span>, <span style='color:#2a00ff; '>'ゲ'</span>, <span style='color:#2a00ff; '>'ゴ'</span>,
    <span style='color:#2a00ff; '>'ザ'</span>, <span style='color:#2a00ff; '>'ジ'</span>, <span style='color:#2a00ff; '>'ズ'</span>, <span style='color:#2a00ff; '>'ゼ'</span>, <span style='color:#2a00ff; '>'ゾ'</span>,
    <span style='color:#2a00ff; '>'ダ'</span>, <span style='color:#2a00ff; '>'ヂ'</span>, <span style='color:#2a00ff; '>'ヅ'</span>, <span style='color:#2a00ff; '>'デ'</span>, <span style='color:#2a00ff; '>'ド'</span>,
    <span style='color:#2a00ff; '>'バ'</span>, <span style='color:#2a00ff; '>'ビ'</span>, <span style='color:#2a00ff; '>'ブ'</span>, <span style='color:#2a00ff; '>'ベ'</span>, <span style='color:#2a00ff; '>'ボ'</span>,
    <span style='color:#2a00ff; '>'パ'</span>, <span style='color:#2a00ff; '>'ピ'</span>, <span style='color:#2a00ff; '>'プ'</span>, <span style='color:#2a00ff; '>'ペ'</span>, <span style='color:#2a00ff; '>'ポ'</span>,
    <span style='color:#2a00ff; '>'カ'</span>, <span style='color:#2a00ff; '>'キ'</span>, <span style='color:#2a00ff; '>'ク'</span>, <span style='color:#2a00ff; '>'ケ'</span>, <span style='color:#2a00ff; '>'コ'</span>,
    <span style='color:#2a00ff; '>'サ'</span>, <span style='color:#2a00ff; '>'シ'</span>, <span style='color:#2a00ff; '>'ス'</span>, <span style='color:#2a00ff; '>'セ'</span>, <span style='color:#2a00ff; '>'ソ'</span>,
    <span style='color:#2a00ff; '>'タ'</span>, <span style='color:#2a00ff; '>'チ'</span>, <span style='color:#2a00ff; '>'ツ'</span>, <span style='color:#2a00ff; '>'テ'</span>, <span style='color:#2a00ff; '>'ト'</span>,
    <span style='color:#2a00ff; '>'ナ'</span>, <span style='color:#2a00ff; '>'ニ'</span>, <span style='color:#2a00ff; '>'ヌ'</span>, <span style='color:#2a00ff; '>'ネ'</span>, <span style='color:#2a00ff; '>'ノ'</span>,
    <span style='color:#2a00ff; '>'ハ'</span>, <span style='color:#2a00ff; '>'ヒ'</span>, <span style='color:#2a00ff; '>'フ'</span>, <span style='color:#2a00ff; '>'ヘ'</span>, <span style='color:#2a00ff; '>'ホ'</span>,
    <span style='color:#2a00ff; '>'マ'</span>, <span style='color:#2a00ff; '>'ミ'</span>, <span style='color:#2a00ff; '>'ム'</span>, <span style='color:#2a00ff; '>'メ'</span>, <span style='color:#2a00ff; '>'モ'</span>,
    <span style='color:#2a00ff; '>'ヤ'</span>,       <span style='color:#2a00ff; '>'ユ'</span>,       <span style='color:#2a00ff; '>'ヨ'</span>,
    <span style='color:#2a00ff; '>'ラ'</span>, <span style='color:#2a00ff; '>'リ'</span>, <span style='color:#2a00ff; '>'ル'</span>, <span style='color:#2a00ff; '>'レ'</span>, <span style='color:#2a00ff; '>'ロ'</span>,
    <span style='color:#2a00ff; '>'ワ'</span>, <span style='color:#2a00ff; '>'ヰ'</span>,       <span style='color:#2a00ff; '>'ヱ'</span>, <span style='color:#2a00ff; '>'ヲ'</span>,
    <span style='color:#2a00ff; '>'ン'</span>, <span style='color:#2a00ff; '>'ッ'</span>,
    <span style='color:#2a00ff; '>'ア'</span>, <span style='color:#2a00ff; '>'イ'</span>, <span style='color:#2a00ff; '>'ウ'</span>, <span style='color:#2a00ff; '>'エ'</span>, <span style='color:#2a00ff; '>'オ'</span>,
    <span style='color:#2a00ff; '>'ャ'</span>,       <span style='color:#2a00ff; '>'ュ'</span>,       <span style='color:#2a00ff; '>'ョ'</span>,
    <span style='color:#2a00ff; '>'ァ'</span>, <span style='color:#2a00ff; '>'ィ'</span>, <span style='color:#2a00ff; '>'ゥ'</span>, <span style='color:#2a00ff; '>'ェ'</span>, <span style='color:#2a00ff; '>'ォ'</span>,
];

<span style='color:#3f7f59; '>//Transliterations of coreHiragana</span>
<span style='color:#7f0055; font-weight:bold; '>var</span> coreRomaji =
[
    <span style='color:#2a00ff; '>'ga'</span>, <span style='color:#2a00ff; '>'gi'</span>, <span style='color:#2a00ff; '>'gu'</span>, <span style='color:#2a00ff; '>'ge'</span>, <span style='color:#2a00ff; '>'go'</span>,
    <span style='color:#2a00ff; '>'za'</span>, <span style='color:#2a00ff; '>'ji'</span>, <span style='color:#2a00ff; '>'zu'</span>, <span style='color:#2a00ff; '>'ze'</span>, <span style='color:#2a00ff; '>'zo'</span>,
    <span style='color:#2a00ff; '>'da'</span>, <span style='color:#2a00ff; '>'di'</span>, <span style='color:#2a00ff; '>'du'</span>, <span style='color:#2a00ff; '>'de'</span>, <span style='color:#2a00ff; '>'do'</span>,
    <span style='color:#2a00ff; '>'ba'</span>, <span style='color:#2a00ff; '>'bi'</span>, <span style='color:#2a00ff; '>'bu'</span>, <span style='color:#2a00ff; '>'be'</span>, <span style='color:#2a00ff; '>'bo'</span>,
    <span style='color:#2a00ff; '>'pa'</span>, <span style='color:#2a00ff; '>'pi'</span>, <span style='color:#2a00ff; '>'pu'</span>, <span style='color:#2a00ff; '>'pe'</span>, <span style='color:#2a00ff; '>'po'</span>,
    <span style='color:#2a00ff; '>'ka'</span>, <span style='color:#2a00ff; '>'ki'</span>, <span style='color:#2a00ff; '>'ku'</span>, <span style='color:#2a00ff; '>'ke'</span>, <span style='color:#2a00ff; '>'ko'</span>,
    <span style='color:#2a00ff; '>'sa'</span>, <span style='color:#2a00ff; '>'shi'</span>, <span style='color:#2a00ff; '>'su'</span>, <span style='color:#2a00ff; '>'se'</span>, <span style='color:#2a00ff; '>'so'</span>,
    <span style='color:#2a00ff; '>'ta'</span>, <span style='color:#2a00ff; '>'chi'</span>, <span style='color:#2a00ff; '>'tsu'</span>, <span style='color:#2a00ff; '>'te'</span>, <span style='color:#2a00ff; '>'to'</span>,
    <span style='color:#2a00ff; '>'na'</span>, <span style='color:#2a00ff; '>'ni'</span>, <span style='color:#2a00ff; '>'nu'</span>, <span style='color:#2a00ff; '>'ne'</span>, <span style='color:#2a00ff; '>'no'</span>,
    <span style='color:#2a00ff; '>'ha'</span>, <span style='color:#2a00ff; '>'hi'</span>, <span style='color:#2a00ff; '>'fu'</span>, <span style='color:#2a00ff; '>'he'</span>, <span style='color:#2a00ff; '>'ho'</span>,
    <span style='color:#2a00ff; '>'ma'</span>, <span style='color:#2a00ff; '>'mi'</span>, <span style='color:#2a00ff; '>'mu'</span>, <span style='color:#2a00ff; '>'me'</span>, <span style='color:#2a00ff; '>'mo'</span>,
    <span style='color:#2a00ff; '>'ya'</span>,       <span style='color:#2a00ff; '>'yu'</span>,       <span style='color:#2a00ff; '>'yo'</span>,
    <span style='color:#2a00ff; '>'ra'</span>, <span style='color:#2a00ff; '>'ri'</span>, <span style='color:#2a00ff; '>'ru'</span>, <span style='color:#2a00ff; '>'re'</span>, <span style='color:#2a00ff; '>'ro'</span>,
    <span style='color:#2a00ff; '>'wa'</span>, <span style='color:#2a00ff; '>'wi'</span>,       <span style='color:#2a00ff; '>'we'</span>, <span style='color:#2a00ff; '>'wo'</span>,
    <span style='color:#2a00ff; '>'n'</span>,  <span style='color:#2a00ff; '>'ッ'</span>,  <span style='color:#3f7f59; '>//preserve chiisai tsu</span>
    <span style='color:#2a00ff; '>'a'</span>,  <span style='color:#2a00ff; '>'i'</span>,  <span style='color:#2a00ff; '>'u'</span>,  <span style='color:#2a00ff; '>'e'</span>,  <span style='color:#2a00ff; '>'o'</span>,
    <span style='color:#2a00ff; '>'ya'</span>,       <span style='color:#2a00ff; '>'yu'</span>,       <span style='color:#2a00ff; '>'yo'</span>,
    <span style='color:#2a00ff; '>'a'</span>,  <span style='color:#2a00ff; '>'i'</span>,  <span style='color:#2a00ff; '>'u'</span>,  <span style='color:#2a00ff; '>'e'</span>,  <span style='color:#2a00ff; '>'o'</span>,
];

<span style='color:#3f7f59; '>//All "combination" katakana</span>
<span style='color:#7f0055; font-weight:bold; '>var</span> comboKatakana =
[
    <span style='color:#2a00ff; '>'チャ'</span>, <span style='color:#2a00ff; '>'チュ'</span>, <span style='color:#2a00ff; '>'チェ'</span>, <span style='color:#2a00ff; '>'チョ'</span>,
    <span style='color:#2a00ff; '>'シャ'</span>, <span style='color:#2a00ff; '>'シュ'</span>, <span style='color:#2a00ff; '>'シェ'</span>, <span style='color:#2a00ff; '>'ショ'</span>,
    <span style='color:#2a00ff; '>'ジャ'</span>, <span style='color:#2a00ff; '>'ジュ'</span>, <span style='color:#2a00ff; '>'ジェ'</span>, <span style='color:#2a00ff; '>'ジョ'</span>,
    <span style='color:#2a00ff; '>'キャ'</span>, <span style='color:#2a00ff; '>'キュ'</span>,        <span style='color:#2a00ff; '>'キョ'</span>,
    <span style='color:#2a00ff; '>'ギャ'</span>, <span style='color:#2a00ff; '>'ギュ'</span>,        <span style='color:#2a00ff; '>'ギョ'</span>,
           <span style='color:#2a00ff; '>'リュ'</span>,         <span style='color:#2a00ff; '>'リョ'</span>,
    <span style='color:#2a00ff; '>'ミャ'</span>, <span style='color:#2a00ff; '>'ミュ'</span>,         <span style='color:#2a00ff; '>'ミョ'</span>,
    <span style='color:#2a00ff; '>'ヒャ'</span>, <span style='color:#2a00ff; '>'ヒュ'</span>,         <span style='color:#2a00ff; '>'ヒョ'</span>,
    <span style='color:#2a00ff; '>'ニャ'</span>, <span style='color:#2a00ff; '>'ニュ'</span>,         <span style='color:#2a00ff; '>'ニョ'</span>,
    <span style='color:#2a00ff; '>'ビャ'</span>, <span style='color:#2a00ff; '>'ビュ'</span>,         <span style='color:#2a00ff; '>'ビョ'</span>,
    <span style='color:#2a00ff; '>'ピャ'</span>, <span style='color:#2a00ff; '>'ピュ'</span>,         <span style='color:#2a00ff; '>'ピョ'</span>,
    <span style='color:#2a00ff; '>'ヂャ'</span>, <span style='color:#2a00ff; '>'ヂュ'</span>,         <span style='color:#2a00ff; '>'ヂョ'</span>,
    <span style='color:#2a00ff; '>'ファ'</span>, <span style='color:#2a00ff; '>'フィ'</span>, <span style='color:#2a00ff; '>'フェ'</span>, <span style='color:#2a00ff; '>'フォ'</span>,
           <span style='color:#2a00ff; '>'ウィ'</span>, <span style='color:#2a00ff; '>'ウェ'</span>,  <span style='color:#2a00ff; '>'ウォ'</span>,
    <span style='color:#2a00ff; '>'ヴァ'</span>, <span style='color:#2a00ff; '>'ヴィ'</span>, <span style='color:#2a00ff; '>'ヴェ'</span>, <span style='color:#2a00ff; '>'ヴォ'</span>,
           <span style='color:#2a00ff; '>'ティ'</span>,
           <span style='color:#2a00ff; '>'ディ'</span>
];

<span style='color:#3f7f59; '>//Transliterations of comboKatakana</span>
<span style='color:#7f0055; font-weight:bold; '>var</span> comboRomaji =
[
    <span style='color:#2a00ff; '>'cha'</span>, <span style='color:#2a00ff; '>'chu'</span>, <span style='color:#2a00ff; '>'che'</span>, <span style='color:#2a00ff; '>'cho'</span>,
    <span style='color:#2a00ff; '>'sha'</span>, <span style='color:#2a00ff; '>'shu'</span>, <span style='color:#2a00ff; '>'she'</span>, <span style='color:#2a00ff; '>'sho'</span>,
    <span style='color:#2a00ff; '>'ja'</span>,  <span style='color:#2a00ff; '>'ju'</span>,  <span style='color:#2a00ff; '>'je'</span>,  <span style='color:#2a00ff; '>'jo'</span>,
    <span style='color:#2a00ff; '>'kya'</span>, <span style='color:#2a00ff; '>'kyu'</span>,        <span style='color:#2a00ff; '>'kyo'</span>,
    <span style='color:#2a00ff; '>'gya'</span>, <span style='color:#2a00ff; '>'gyu'</span>,        <span style='color:#2a00ff; '>'gyo'</span>,
           <span style='color:#2a00ff; '>'ryu'</span>,        <span style='color:#2a00ff; '>'ryo'</span>,
    <span style='color:#2a00ff; '>'mya'</span>, <span style='color:#2a00ff; '>'myu'</span>,        <span style='color:#2a00ff; '>'myo'</span>,
    <span style='color:#2a00ff; '>'hya'</span>, <span style='color:#2a00ff; '>'hyu'</span>,        <span style='color:#2a00ff; '>'hyo'</span>,
    <span style='color:#2a00ff; '>'nya'</span>, <span style='color:#2a00ff; '>'nyu'</span>,        <span style='color:#2a00ff; '>'nyo'</span>,
    <span style='color:#2a00ff; '>'bya'</span>, <span style='color:#2a00ff; '>'byu'</span>,        <span style='color:#2a00ff; '>'byo'</span>,
    <span style='color:#2a00ff; '>'pya'</span>, <span style='color:#2a00ff; '>'pyu'</span>,        <span style='color:#2a00ff; '>'pyo'</span>,
    <span style='color:#2a00ff; '>'dya'</span>, <span style='color:#2a00ff; '>'dyu'</span>,        <span style='color:#2a00ff; '>'dyo'</span>,
    <span style='color:#2a00ff; '>'fa'</span>,  <span style='color:#2a00ff; '>'fi'</span>,  <span style='color:#2a00ff; '>'fe'</span>,  <span style='color:#2a00ff; '>'fo'</span>,
           <span style='color:#2a00ff; '>'wi'</span>,  <span style='color:#2a00ff; '>'we'</span>,  <span style='color:#2a00ff; '>'wo'</span>,
    <span style='color:#2a00ff; '>'va'</span>,  <span style='color:#2a00ff; '>'vi'</span>,  <span style='color:#2a00ff; '>'ve'</span>,  <span style='color:#2a00ff; '>'vo'</span>,
           <span style='color:#2a00ff; '>'ti'</span>,
           <span style='color:#2a00ff; '>'di'</span>
];

<span style='color:#3f7f59; '>//----/end character tables-----------------------------------------------------</span></code>


<p>The "combo" tables represent larger Japanese phonics that are written with two characters.
We need to search and replace these first in order to prevent splitting any of them up
by searching and replacing single characters first.</p>

<p>Note that we don't define a "comboHiragana" table because we can get that
by computing <code>comboKatakana.str_replace(coreKatakana, coreHiragana);</code>
if we need to.</p>

<p><code>romaji_to_hira()</code> is going to now look like this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Convert romaji to hiragana</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> romaji_to_hira(romajiString)
{
    <span style='color:#3f7f59; '>//replace combos first</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> katakana = romajiString
            .str_replace(comboRomaji, comboKatakana)
            .str_replace(coreRomaji, coreKatakana);
    
    <span style='color:#3f7f59; '>//force hiragana</span>
    <span style='color:#7f0055; font-weight:bold; '>return</span> kata_to_hira(katakana);
}</code>

<p>We accept a string in romaji (abc) and then run <code>String.str_replace()</code> on it <em>twice</em> using
a technique called chaining. We replace combo characters first and then single
characters.
We now have a converted string in katakana, but as the function name implies we want
to return hiragana. We return the katakana as modified by <code>kata_to_hira()</code> which we
implement, again in <code class="file">linguistics.js</code>, thus:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Convert katakana to hiragana</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> kata_to_hira(katakanaString)
{
    <span style='color:#7f0055; font-weight:bold; '>return</span> katakanaString.str_replace(coreKatakana, coreHiragana);
}</code>

<p>Here we simply replace all katakana with the corresponding hiragana.
We don't need to bother with combo characters here as this will
cover all cases.</p>

<p>The English search route is ready to go! Give it a whirl by searching for some
words and seeing what - if any - results you get. To be double dog sure
that we are trying exact definition matches first and then falling back to 
partial matches, have a peek at the <code class="file">websql_edict_inserts.sql</code> file again
and pick out some definitions to searh for.</p>

<p>In fact, we've not had any screenshots of the app for a while so let's have 
one for each type of search (kanji, kana, English exact, English partial):</p>

<div class="figure">
    <img src="img/figure/fig_310.png">
    <p>Figure 31. Respective results for kanji, kana, English (exact matches found) and English (partial matches found) queries</p>
</div>

<p>Great! Though looking at these reminds us that we still need to,
in <code>putResultsOnPage()</code> of <code class="file">search_interface.js</code>, somehow convert the kana
field from the database into romaji to make our result lines easier to understand.
In that function, change this bit:</p>

<code class="multiline">var theRomaji = item.kana;    //TODO</code>

<p>to this:</p>

<code class="multiline">var theRomaji = kana_to_romaji(item.kana);</code>

<p>Let's implement <code>kana_to_romaji()</code> in <code class="file">linguistics.js</code> and it will be somewhat the opposite
of our current <code>romaji_to_hira()</code>. <code>kana_to_romaji()</code> is like this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Convert kana (hira or kata) to romaji</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> kana_to_romaji(kanaString)
{
    <span style='color:#3f7f59; '>//force katakana</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> kata = hira_to_kata(kanaString);
    
    <span style='color:#3f7f59; '>//transliterate</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> withChiisaiTsu = kata.str_replace(comboKatakana, comboRomaji)
                            .str_replace(coreKatakana, coreRomaji);
    
    <span style='color:#3f7f59; '>//fix any remaining chiisai tsu's</span>
        <span style='color:#3f7f59; '>//before 'chi' (make "tchi")</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> romaji = withChiisaiTsu.<span style='color:#7f0055; font-weight:bold; '>replace</span>(<span style='color:#2a00ff; '>/</span><span style='color:#2a00ff; '>ッchi</span><span style='color:#2a00ff; '>/</span><span style='color:#7f0055; font-weight:bold; '>g</span>, <span style='color:#2a00ff; '>'tchi'</span>);
        <span style='color:#3f7f59; '>//before anything else (double the consonant)</span>
    romaji = romaji.<span style='color:#7f0055; font-weight:bold; '>replace</span>(<span style='color:#2a00ff; '>/</span><span style='color:#2a00ff; '>ッ</span><span style='color:#2a00ff; '>(</span><span style='color:#2a00ff; '>[</span><span style='color:#2a00ff; '>a</span><span style='color:#2a00ff; '>-</span><span style='color:#2a00ff; '>z</span><span style='color:#2a00ff; '>]</span><span style='color:#2a00ff; '>{</span><span style='color:#2a00ff; '>1</span><span style='color:#2a00ff; '>}</span><span style='color:#2a00ff; '>)</span><span style='color:#2a00ff; '>/</span><span style='color:#7f0055; font-weight:bold; '>g</span>, <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>$1$1</span><span style='color:#2a00ff; '>"</span>);
    
    <span style='color:#3f7f59; '>//TODO katakana style 'ー' (which might actually be '-' in the input string)</span>
    romaji = romaji.<span style='color:#7f0055; font-weight:bold; '>replace</span>(<span style='color:#2a00ff; '>/</span><span style='color:#2a00ff; '>(</span><span style='color:#2a00ff; '>[</span><span style='color:#2a00ff; '>^</span><span style='color:#2a00ff; '>0</span><span style='color:#2a00ff; '>-</span><span style='color:#2a00ff; '>9</span><span style='color:#2a00ff; '>]</span><span style='color:#2a00ff; '>)</span><span style='color:#2a00ff; '>[</span><span style='color:#2a00ff; '>-</span><span style='color:#2a00ff; '>]</span><span style='color:#2a00ff; '>(</span><span style='color:#2a00ff; '>[</span><span style='color:#2a00ff; '>^</span><span style='color:#2a00ff; '>0</span><span style='color:#2a00ff; '>-</span><span style='color:#2a00ff; '>9</span><span style='color:#2a00ff; '>]</span><span style='color:#2a00ff; '>)</span><span style='color:#2a00ff; '>/</span><span style='color:#7f0055; font-weight:bold; '>g</span>, <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>$1ー$2</span><span style='color:#2a00ff; '>"</span>);
    romaji = romaji.<span style='color:#7f0055; font-weight:bold; '>replace</span>(<span style='color:#2a00ff; '>/</span><span style='color:#2a00ff; '>(</span><span style='color:#2a00ff; '>[</span><span style='color:#2a00ff; '>a</span><span style='color:#2a00ff; '>-</span><span style='color:#2a00ff; '>z</span><span style='color:#2a00ff; '>]</span><span style='color:#2a00ff; '>{</span><span style='color:#2a00ff; '>1</span><span style='color:#2a00ff; '>}</span><span style='color:#2a00ff; '>)</span><span style='color:#2a00ff; '>ー</span><span style='color:#2a00ff; '>/</span><span style='color:#7f0055; font-weight:bold; '>g</span>, <span style='color:#2a00ff; '>"</span><span style='color:#2a00ff; '>$1$1</span><span style='color:#2a00ff; '>"</span>);
    
    <span style='color:#7f0055; font-weight:bold; '>return</span> romaji;
}</code>

<p>Again it's best to think of this as a black box, but what it's doing is the opposite of 
<code>romaji_to_hira()</code> but with some extra cleanup steps at the end.
Searching for anything now has romaji (abc) in brackets on each result line:</p>

<div class="figure">
    <img src="img/figure/fig_320.png">
    <p>Figure 32. We now get each result word spelled out in abc (romaji)</p>
</div>

<p>Sweet!</p>

<p>Before scrolling - which will be epic - there's just one more niggle. You might have noticed so far that we
can get search results by clicking the search button, but <strong>not</strong> by pressing enter (or equivalent)
on the on-screen keyboard after we've typed the search term.
Correctly implemented HTML forms will let you press enter in a text input field
to submit the form. It will perform the same as clicking the form's submit button.
We don't technically have a &lt;form> here - as we aren't submitting to a remote server, it's all client-side - but we should emulate this behaviour because:</p>

<ul>
<li>Other apps do it</li>
<li>It is expected UX and is "normal"</li>
</ul>

<p>It is surprisingly easy to implement, we simply need a handler for <em>keypress</em> events on
the search input. This event fires every time a character is typed and then inserted into a text
input or textarea etc. The event will tell us which key was pressed and we simply need to
treat the ENTER key as a special case because we then want to do some processing (and not put a character
into the text field).</p>

<p>Stick a:</p>

<code class="multiline">configureSearchInput();</code>

<p>at the bottom of <code>receivedEvent()</code> in <code class="file">index.js</code>.
Define this function in <code class="file">search_interface.js</code> thus:</p>

<code class="multiline"><span style='color:#3f7f59; '>//search box ENTER keypress</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> configureSearchInput()
{
    document.getElementById(<span style='color:#2a00ff; '>'search-query'</span>).addEventListener(<span style='color:#2a00ff; '>'keypress'</span>, onkeyForSearchInput, <span style='color:#7f0055; font-weight:bold; '>false</span>);
}</code>

<p>We set <code>onkeyForSearchInput()</code> as the keypress handler for our search text input.
<code>onkeyForSearchInput()</code> also lives in <code class="file">search_interface.js</code> and is this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Simulate a "normal" HTML form input by allowing an ENTER press in the</span>
<span style='color:#3f7f59; '>//query input to perform the same as clicking the search button</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> onkeyForSearchInput(event)
{
    <span style='color:#3f7f59; '>//.charCode or .keyCode ??</span>
    <span style='color:#7f0055; font-weight:bold; '>if</span>(event.keyCode == 13) <span style='color:#3f7f59; '>//ENTER key</span>
    {
        <span style='color:#3f7f59; '>//trigger the already registered "click" handler</span>
        document.getElementById(<span style='color:#2a00ff; '>'search-button'</span>).click();
    }
}</code>

<p>We simply use the keyCode property of the received event to detect an ENTER press
and then call the already registered click handler for the search button.
For anything other than ENTER, we "do nothing".
How we call the click handler manually is worth talking about. We simply
get the relevant DOM element using <code>document.getElementById()</code> (or you could use <code>document.querySelector()</code>
or what-have-you) and then call <code>.click()</code> on it. This will trigger the registered click
handler for that element.</p>

<p>You'll be wondering now "but our click handler for the search button receives a mouse event
 - a click in fact. What will it receive in this case?"
Interestingly, after manually calling <code>.click()</code> on an element, that element's click handler
will be triggered with a <em>dummy</em> mouse event (where, for example, the x and y coordinates are zero
and etc). Depending on what you do with the mouse event in the click handler, it may or may
not make sense to call it manually with <code>.click()</code>. In our case, the click handler doesn't
even use the received event, and so we are fine.</p>

<p>Give it a whirl! You can now search by hitting the ENTER (or equivalent) key after typing a search term. It will work on desktop Chrome or your device!
Sweet!</p>


<h3 id="the_search_tab_iv">Results scrolling</h3>

<p>The final epic thing on our Search tab is results scrolling. You've probably
already noticed that if your search produces lots of results, it is simply clipped
at the bottom of the screen (actually just above our footer). If you haven't noticed
this yet, then try searching for "it's" and you'll see the problem.</p>


<p>With desktop Chrome, you can scroll as per normal with the scrollbar that appears - or your mouse wheel.
In fact, the search box and search button also scroll
because this is the <code>japxlate_app</code> div that is scrolling,
due to CSS <code>overflow:auto;</code></p>

<p>So why don't we have scrollbars or scrollability
on the device?
It's because the Android WebView browser (and the
stock browser app) will only allow scrolling when
the entire html document itself is larger than
the viewport. Even then it doesn't show scrollbars.
It would be very very fiddly on a small mobile screen
if, say, the html document itself was scrollable and then
a small div inside of that was scrollable too! This
is why CSS scrolling does not work on WebView.</p>

<p>What we need to do is to use browser events to implement
our own scrolling for search results. Also, let's limit
scrollability to our #results-wrapper div so that
we don't scroll the search box and button.</p>

<p>So, we probably want to detect a finger drag on the results
and then scroll based on that. And we've just seen that
the DOM event of "click" (on the search button) worked for
both mouse clicks and finger taps.
So, to detect a finger drag on our device we can probably
just detect a "mousemove" event or something like that huh?
Annoyingly no. The "traditional" DOM mouse events of
"mousedown", "mousemove" and "mouseup" do NOT get triggered
in WebView when putting a finger down, moving and then
releasing the finger. This is initially very annoying and
confusing, but it makes sense really because of things
like multi-finger gestures which obviously have no parallel on a mouse. Maybe in the future there will
even be pressure sensitive mobile screens?</p>

<p>The events in question are touchstart, touchmove and touchend.
These somewhat correlate to the mousedown, mousemove, and
mouseup events. Remembering that the parent #results-wrapper div is actually our
static "window" on the search results, we need to attach scrolling behaviour to
#search-results which is where the search result content gets written to.</p>

<p>Mosey on back to <code>receivedEvent()</code> in <code class="file">index.js</code> and stick a call to:</p>

<code class="multiline">configureSearchTouchScrolling();</code>

<p>at the bottom. And yes, you've guessed it, we are going to define this function in <code class="file">search_interface.js</code>
. thus:</p>

<code class="multiline"><span style='color:#3f7f59; '>//configure touch dragging for search results</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> configureSearchTouchScrolling()
{
    document.getElementById(<span style='color:#2a00ff; '>'search-results'</span>)
            .addEventListener(<span style='color:#2a00ff; '>'touchstart'</span>, touchstartForSearchResults, <span style='color:#7f0055; font-weight:bold; '>false</span>);
    
    document.getElementById(<span style='color:#2a00ff; '>'search-results'</span>)
            .addEventListener(<span style='color:#2a00ff; '>'touchmove'</span>, touchmoveForSearchResults, <span style='color:#7f0055; font-weight:bold; '>false</span>);
    
    document.getElementById(<span style='color:#2a00ff; '>'search-results'</span>)
            .addEventListener(<span style='color:#2a00ff; '>'touchend'</span>, touchendForSearchResults, <span style='color:#7f0055; font-weight:bold; '>false</span>);
}</code>

<p>We simply register one custom handler function for each of the touch events.
To get the ball rolling, define placeholders for these handlers - still in <code class="file">search_interface.js</code> - thus:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Touchstart event handler for search results div - initiates touch scrolling</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> touchstartForSearchResults(event)
{
    console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'touchstart'</span>);
}

<span style='color:#3f7f59; '>//Touchmove event handler for search results div - performs touch scrolling</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> touchmoveForSearchResults(event)
{
    console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'touchmove'</span>);
}

<span style='color:#3f7f59; '>//Touchend event handler for search results div</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> touchendForSearchResults(event)
{
    console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'touchend'</span>);
}</code>

<p>This is now runnable but note that it won't do anything on your desktop Chrome as
nothing can trigger touch events! So run this on your device, search for "it's" (a good
test as it matches a <strong>lot</strong> of entries) and then drag your finger up and down over the results.
Your Eclipse LogCat will show something like this:</p>

<div class="figure">
    <img src="img/figure/fig_330.png">
    <p>Figure 33. Touch events captured in LogCat</p>
</div>

<p>Nice! Of interest is that if you <em>tap</em> the results, you'll trigger a touchstart immediately followed
by a touchend. ie. there will be no "move".</p>
<p>Cool, so we are already catching the events that we need for scrolling, we just need to scroll!
What we'll do is we'll get the y (or vertical) coordinate of wherever the finger was moved to,
and use that to change the CSS top property of #search-results accordingly. Remember that we
set #search-results to <code>position:relative;</code> which means that we can set its "top" property to any value (in pixels)
that we like. A negative top will move the results up and a positive top will move the results down.
Essentially, if a finger touches at y=60 and then moves up to y=30 (a lower y is higher up the screen)
we know that we should move the results div up by 30; which is to say a top value of -30px.</p>

<p>OK, we've already got three different touch events each with its own handler function.
I'm thinking already that we are going to need some evil global variables to store
things that will be shared between these handlers. For example, finger y positions and so on.
Stick these at the top of <code class="file">search_interface.js</code>:</p>

<code class="multiline"><span style='color:#3f7f59; '>//start y axis position (in pixels) of the current scroll</span>
<span style='color:#7f0055; font-weight:bold; '>var</span> global_scrollStartY;

<span style='color:#3f7f59; '>//current 'top' css value (in pixels) of our scrollable div</span>
<span style='color:#7f0055; font-weight:bold; '>var</span> global_scrollDivTop;

<span style='color:#3f7f59; '>//height (in pixels) of our viewport over the scrollable div (used to activate scrolling)</span>
<span style='color:#7f0055; font-weight:bold; '>var</span> global_scrollWindowHeight;

<span style='color:#3f7f59; '>//current height (in pixels) of our scrollable div's content (used to activate scrolling and for scroll locking)</span>
<span style='color:#7f0055; font-weight:bold; '>var</span> global_scrollDivHeight;</code>

<p>For every finger scroll we want to know the start y of the results div and the start y of the finger.
Then we can find out how far up (or down) the finger moves and simply subtract (or add) this to the
top value of the results div. We also need to know (a) do we need scrolling at all? and (b) when to
stop scrolling to prevent content being scrolled off the viewport! For both (a) and (b) we save the height
of the scrollable content and the height of the scroll viewport.
We saw earlier from fiddling with the device screen and looking at LogCat that finger scrolling
is split into three steps; touchstart, touchmove then touchend. We'll map these three different
events to three different steps for our scrolling. Thus:</p>

<ul>
<li>touchstart => finger scrolling <em>may</em> start</li>
<li>touchmove => finger scrolling happening now!</li>
<li>touchend => finger scrolling (if it was happening at all) has stopped</li>
</ul>

<p>Sidenote now, but have you noticed that we are no longer able to debug results scrolling in
desktop Chrome? To get rid of this annoyance, we'll implement our touch scrolling in as generic
a way as possible so that we can - a little bit later in the tutorial - add <em>simulated</em> touch
scrolling by using mouse events instead of touch events.</p>

<p>OK, go back to <code>touchstartForSearchResults()</code> and <code>touchmoveForSearchResults()</code> and make them look
a bit like this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Touchstart event handler for search results div - initiates touch scrolling</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> touchstartForSearchResults(event)
{
    <span style='color:#3f7f59; '>//console.log('touchstart');</span>
    
    touchobj = event.changedTouches[0]; <span style='color:#3f7f59; '>//reference *first* touch point</span>
  
    startVerticalDragScrolling(<span style='color:#7f0055; font-weight:bold; '>this</span>, touchobj.clientY);
    
    event.preventDefault(); <span style='color:#3f7f59; '>//prevent default tap behavior</span>
}

<span style='color:#3f7f59; '>//Touchmove event handler for search results div - performs touch scrolling</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> touchmoveForSearchResults(event)
{
    <span style='color:#3f7f59; '>//console.log('touchmove');</span>
    
    touchobj = event.changedTouches[0]; <span style='color:#3f7f59; '>//reference first touch point for this event</span>
    
    doVerticalDragScrolling(<span style='color:#7f0055; font-weight:bold; '>this</span>, touchobj.clientY);
    
    event.preventDefault();
}</code>

<p>Well we don't do much in these handler functions themselves, other than call soon-to-be-written
helper functions and then preventing the default action for the touch event in question.
We bundle away scroller functionality into helper functions to keep things nice and generic
which will help us later when we go back and get scrolling working with the mouse.
As the default behaviour for dragging a finger over some text would be to select that text,
we prevent this default.</p>

<p>The key point here is how to use the touch event that we receive.
Touch events contain a <code>changedTouches</code> property which is an array of touch objects.
Each touch object in the array represents a single touch directly involved in
this event. Which for touchstart means all the fingers that hit the screen, and for
touchmove means all the fingers that moved.</p>

<p>As we don't need or want to do anything fancy with
multi touch gestures on Japxlate, we can simply
access <code>.changedTouches[0]</code> and ignore the rest.
There will always be at least one touch object
in <code>changedTouches[0]</code>, and there may or may not be more.</p>

<p>We pass the clientY property of our touch object to 
our helper functions. As the first argument, we also pass 'this',
which if you remember for event handler functions
means the element that the event triggered on - in this
case the search results div.</p>

<p>See <a href="http://www.javascriptkit.com/javatutors/touchevents.shtml">http://www.javascriptkit.com/javatutors/touchevents.shtml</a> for more
about touch events in JavaScript.</p>



<div class="sidenote">
NOTETOSELF
SIDNOTE about the different JavaScript event coordinate systems

[dont 4get that for mobile there is one extra which is the current poz of the small device window on the bigger client window
</div>

<p>OK, so the meat-and-bones of scrolling are bundled away in helper functions.
Let's have a look at our scroll initiator - <code>startVerticalDragScrolling()</code> - first
of all:</p>

<code class="multiline"><span style='color:#3f7f59; '>//initialise vertical scrolling for ontouchmove</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> startVerticalDragScrolling(elementToScroll, eventClientY)
{
    <span style='color:#3f7f59; '>//console.log('initialise scrolling');</span>
    
    <span style='color:#7f0055; font-weight:bold; '>var</span> theStyle = window.getComputedStyle(elementToScroll);
    
    global_scrollDivTop = <span style='color:#7f0055; font-weight:bold; '>parseInt</span>(theStyle.top);  <span style='color:#3f7f59; '>//get 'top' value of box</span>
    global_scrollStartY = <span style='color:#7f0055; font-weight:bold; '>parseInt</span>(eventClientY); <span style='color:#3f7f59; '>// get x coord of touch point</span>
    
    global_scrollDivHeight = <span style='color:#7f0055; font-weight:bold; '>parseInt</span>(theStyle.height); <span style='color:#3f7f59; '>//get 'height' value of box</span>
    
    <span style='color:#3f7f59; '>//work out height of #search-results versus height of results</span>
    <span style='color:#3f7f59; '>//pane (which is .japxlate_app.height - #search-form.height)</span>
    global_scrollWindowHeight =
        <span style='color:#7f0055; font-weight:bold; '>parseInt</span>(
            window.getComputedStyle(
                document.querySelector(<span style='color:#2a00ff; '>'.japxlate_app'</span>)
            ).height, 10) -
            
            <span style='color:#7f0055; font-weight:bold; '>parseInt</span>(
                window.getComputedStyle(
                    document.querySelector(<span style='color:#2a00ff; '>'#search-form'</span>)
            ).height);
}</code>

<p>So we expect to receive an elementToScroll which could be any old element (but with the right CSS
settings) but in our case will be the search-results div. We also expect an eventClientY value.</p>

<p>All we do in this function is save elementToScroll's CSS top value, and eventClientY to the
global variables we defined earlier on. The novelty here is the use of <code>window.getComputedStyle()</code>
which will return the CSS style properties of the specified element, but <strong>not</strong> the developer defined
style as per a CSS stylesheet rule or an inline <code>style="something"</code> attribute. Rather this
will return the CSS properties that the browser's rendering engine has given to the element to
display it where it is. This method is useful to get <em>natural</em> CSS values for elements
that we haven't styled ourselves very aggressively - or at all.</p>


<p>We also save the height of the results div (global_scrollDivHeight) and the height
of the results pane. (The results pane being all the space in .japxlate_app div
<em>under</em> the search form). We do this so we can work out if we actually
need to scroll at all! Note that to get the height of the results pane,
we subtract the height of the search form from the total height of .japxlate_app.
We get the height of the search form by getting the height of the #search-form
wrapper div which we need to implement in <code class="file">index.html</code> thus:</p>

<code class="multiline"><span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>div</span> id=<span style='color:#2a00ff; '>"search"</span> class=<span style='color:#2a00ff; '>"current"</span><span style='color:#7f0055; '>></span>
    <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>div</span> id=<span style='color:#2a00ff; '>"search-form"</span><span style='color:#7f0055; '>></span>
        <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>button</span> type=<span style='color:#2a00ff; '>"button"</span> id=<span style='color:#2a00ff; '>"search-button"</span> style=<span style='color:#2a00ff; '>"</span><span style='color:#7f0055; font-weight:bold; '>float</span>:right; <span style='color:#7f0055; font-weight:bold; '>width</span>:45%; <span style='color:#7f0055; font-weight:bold; '>margin-right</span>:1%;<span style='color:#2a00ff; '>"</span><span style='color:#7f0055; '>></span>
            <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>img</span> src=<span style='color:#2a00ff; '>"img/search.png"</span><span style='color:#7f0055; '>></span>
            Search
            <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>img</span> id=<span style='color:#2a00ff; '>"button-spinner"</span> src=<span style='color:#2a00ff; '>"img/spinner.gif"</span> style=<span style='color:#2a00ff; '>"</span><span style='color:#7f0055; font-weight:bold; '>visibility</span>:hidden;<span style='color:#2a00ff; '>"</span><span style='color:#7f0055; '>></span>
        <span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>button</span><span style='color:#7f0055; '>></span>
        <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>input</span> type=<span style='color:#2a00ff; '>"text"</span> id=<span style='color:#2a00ff; '>"search-query"</span> placeholder=<span style='color:#2a00ff; '>"Japanese or English"</span> size=<span style='color:#2a00ff; '>"40"</span>
               style=<span style='color:#2a00ff; '>"</span><span style='color:#7f0055; font-weight:bold; '>width</span>:45%; <span style='color:#7f0055; font-weight:bold; '>margin-left</span>:1%;<span style='color:#2a00ff; '>"</span><span style='color:#7f0055; '>></span>
        <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>br</span><span style='color:#7f0055; '>></span>
        <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>span</span> id=<span style='color:#2a00ff; '>"loading-text"</span><span style='color:#7f0055; '>></span>
            [Loading core dictionary. This takes a while the first time.
            <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>img</span> src=<span style='color:#2a00ff; '>"img/spinner.gif"</span><span style='color:#7f0055; '>></span>]
        <span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>span</span><span style='color:#7f0055; '>></span>
    <span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>div</span><span style='color:#7f0055; '>></span>
    <span style='color:#7f0055; '>&lt;</span><span style='color:#7f0055; font-weight:bold; '>div</span> id=<span style='color:#2a00ff; '>"results-wrapper"</span><span style='color:#7f0055; '>></span>
    &vellip;
    <span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>div</span><span style='color:#7f0055; '>></span>
    &vellip;
<span style='color:#7f0055; '>&lt;/</span><span style='color:#7f0055; font-weight:bold; '>div</span><span style='color:#7f0055; '>></span></code>


<p>That's the initiator, now on the the actual scroller which is, of course, going to be
a bit more complex. We need to use the global values we just saved to work out how
far we've scrolled and then move the results div accordingly. We also should
check if we need to do any scrolling at all - there might be no overflow of content!</p>

<p>A first bash looks like this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//do vertical scrolling for ontouchmove</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> doVerticalDragScrolling(elementToScroll, eventClientY)
{
    <span style='color:#3f7f59; '>//console.log('do scrolling');</span>
    
    <span style='color:#3f7f59; '>//if height of results content is less than height of results pane,</span>
    <span style='color:#3f7f59; '>//we have no content overflow and so don't need to scroll    </span>
    <span style='color:#7f0055; font-weight:bold; '>if</span>(global_scrollDivHeight &lt; global_scrollWindowHeight)
    {
        console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'no overflow'</span>);
        <span style='color:#7f0055; font-weight:bold; '>return</span>;
    }
    
    <span style='color:#3f7f59; '>//calculate distance travelled by touch point</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> distance = <span style='color:#7f0055; font-weight:bold; '>parseInt</span>(eventClientY) - global_scrollStartY;
    
    <span style='color:#3f7f59; '>//new CSS top for elementToScroll</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> newTop = global_scrollDivTop + distance;
    
    <span style='color:#3f7f59; '>//set the new top value for the div we are moving</span>
    elementToScroll.style.top = newTop + <span style='color:#2a00ff; '>'px'</span>;
}</code>

<p>First and foremost, we return immediately if we see that we don't need to do any scrolling
because the results content div is shorter than the results pane. This prevents the user from
being able to scroll a single result up and down the pane!
Next, we have to work out how far away we are from the touch start point. This distance
becomes the amount we have to add to - or subtract from - the top value of the results
div.
We access the CSS top value directly with <code>elementToScroll.style.top</code>.</p>

<p>This works! Run it on you device! Nice! Just one problem, which we can see with
these screenshots:</p>

<div class="figure">
    <img src="img/figure/fig_340.png">
    <p>Figure 34. We can scroll content past the top (left) and bottom (right) of the scroll viewport</p>
</div>

<p>Currently, we can scroll the content too far in either direction.
We can fix this by editing <code>doVerticalDragScrolling()</code> to look like this:</p>

<code class="multiline"><span style='color:#3f7f59; '>//do vertical scrolling for ontouchmove</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> doVerticalDragScrolling(elementToScroll, eventClientY)
{
    <span style='color:#3f7f59; '>//console.log('do scrolling');</span>
    
    <span style='color:#3f7f59; '>//if height of results content is less than height of results pane,</span>
    <span style='color:#3f7f59; '>//we have no content overflow and so don't need to scroll    </span>
    <span style='color:#7f0055; font-weight:bold; '>if</span>(global_scrollDivHeight &lt; global_scrollWindowHeight)
    {
        console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'no overflow'</span>);
        <span style='color:#7f0055; font-weight:bold; '>return</span>;
    }
    
    <span style='color:#3f7f59; '>//calculate distance travelled by touch point</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> distance = <span style='color:#7f0055; font-weight:bold; '>parseInt</span>(eventClientY) - global_scrollStartY;
    
    <span style='color:#3f7f59; '>//new CSS top for elementToScroll</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> newTop = global_scrollDivTop + distance;
    
    <span style='color:#3f7f59; '>//disallow scrolling bottom of content higher than bottom of results pane</span>
    <span style='color:#3f7f59; '>//(using height of results pane)</span>
    <span style='color:#7f0055; font-weight:bold; '>if</span>(newTop &lt; ((0 - global_scrollDivHeight) + global_scrollWindowHeight))
    {
        console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'top cushion'</span>);
        <span style='color:#7f0055; font-weight:bold; '>return</span>; <span style='color:#3f7f59; '>//return false??</span>
    }
    
    <span style='color:#3f7f59; '>//disallow scrolling top of content lower than top of results pane</span>
    <span style='color:#7f0055; font-weight:bold; '>if</span>(newTop > 0)
    {
        console.<span style='color:#7f0055; font-weight:bold; '>log</span>(<span style='color:#2a00ff; '>'bottom cushion'</span>);
        <span style='color:#7f0055; font-weight:bold; '>return</span>; <span style='color:#3f7f59; '>//return false?</span>
    }
    
    <span style='color:#3f7f59; '>//set the new top value for the div we are moving</span>
    elementToScroll.style.top = newTop + <span style='color:#2a00ff; '>'px'</span>;
}</code>

<p>(The changes are the two <code>if</code> clauses before the final <code>elementToScroll.style.top</code>.)
To stop the top of the results going lower than the top of the results pane, we simply
prevent the results div's top property from going higher than zero.
To prevent the bottom of the results from going higher than the bottom of the results pane,
we have to prevent the top value from going less than negative(results height + results pane
height). If the height of the results is 1000 pixels, and we set the results div top to -1000 pixels,
this will put the bottom of the results right at the top of the results pane. From this
state, adding, to top, the height of the results div will put the bottom of the results at the
bottom of the results pane. This is the minimum height we enforce here.
[NOTETOSELF the height of the results div.(?)]
</p>

<p>Run this on your device and you'll see that scrolling is "locked" and behaves
more like native Android.</p>

<p>Great, just one more problem which you might already be thinking about.
Run the app and search for "it's" which produces lots of results. Scroll right to the
bottom of the results. No problems there. But then do a search that only gives a few results
like "gas". Eh? Where are the results? Well, when you scrolled to the bottom of the results
for "it's" you moved the top value of the search results div to quite a high negative number.
This means that the top of the div is very high up on the page, probably higher
that the top of the screen! When you search again, the div is still up there and a short
amount of content will be obscured and not "reach down" to the visible results pane.
Clearly we need to reset the search result div's top on every display of search results.
We can do this quite easily by a simple addition to <code>putResultsOnPage()</code> in
our <code class="file">search_interface.js</code> file. Edit the start of this function to look like:</p>

<code class="multiline"><span style='color:#7f0055; font-weight:bold; '>function</span> putResultsOnPage(results)
{
    <span style='color:#3f7f59; '>//get search results div</span>
    <span style='color:#7f0055; font-weight:bold; '>var</span> theDiv = document.getElementById(<span style='color:#2a00ff; '>'search-results'</span>);
    
    <span style='color:#3f7f59; '>//clear current content</span>
    theDiv.innerHTML = <span style='color:#2a00ff; '>''</span>;
    
    <span style='color:#3f7f59; '>//reset Y position because it might have changed after some touch scrolling frenzy!</span>
    theDiv.style.top = <span style='color:#2a00ff; '>'0'</span>;
    &vellip;
}</code>

<p>The only change here is the new line setting <code>style.top</code> to zero. This is all we need to
fix the scroll problem we've just experienced. Try it!</p>

<p>Money in the bank! Searching and scrolling is operational now and we are ready
to move on to the next tab. But do you remember we talked about, for debugging purposes,
simulating the touch scrolling with mouse events for desktop Chrome? Here's a whistle-stop tour
on getting that working:</p>

<p>At the top of <code class="file">search_interface.js</code> put:</p>
<code class="multiline">var global_mouseButtonDown = false;</code>

<p>At the bottom of <code>receivedEvent()</code> in <code class="file">index.js</code> put:</p>

<code class="multiline">configureSearchMouseScrolling();</code>

<p>In <code class="file">search_results.js</code> add:</p>

<code class="multiline"><span style='color:#3f7f59; '>//configure mouse dragging for search results</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> configureSearchMouseScrolling()
{
    <span style='color:#3f7f59; '>//simulated touch (ie. mouse) dragging for results</span>
    document.getElementById(<span style='color:#2a00ff; '>'search-results'</span>)
            .addEventListener(<span style='color:#2a00ff; '>'mousedown'</span>, mousedownForSearchResults, <span style='color:#7f0055; font-weight:bold; '>false</span>);
    
    document.getElementById(<span style='color:#2a00ff; '>'search-results'</span>)
            .addEventListener(<span style='color:#2a00ff; '>'mousemove'</span>, mousemoveForSearchResults, <span style='color:#7f0055; font-weight:bold; '>false</span>);
    
    document.getElementById(<span style='color:#2a00ff; '>'search-results'</span>)
            .addEventListener(<span style='color:#2a00ff; '>'mouseup'</span>, mouseupForSearchResults, <span style='color:#7f0055; font-weight:bold; '>false</span>);
}</code> 

<p>In <code class="file">search_interface.js</code> add:</p>

<code class="multiline"><span style='color:#3f7f59; '>//Mousedown event handler for search results div - initiates simulated touch scrolling</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> mousedownForSearchResults(event)
{
    <span style='color:#3f7f59; '>//console.log('mousedown event on scrollable');</span>
    
    global_mouseButtonDown = <span style='color:#7f0055; font-weight:bold; '>true</span>;  <span style='color:#3f7f59; '>//set global</span>
    
    startVerticalDragScrolling(<span style='color:#7f0055; font-weight:bold; '>this</span>, event.clientY);
    
    event.preventDefault(); <span style='color:#3f7f59; '>//prevent default click behaviour (ie. select text or whatever)</span>
}

<span style='color:#3f7f59; '>//Mousemove event handler for search results div - performs simulated touch scrolling</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> mousemoveForSearchResults(event)
{
    <span style='color:#3f7f59; '>//console.log('mousemove event on scrollable');</span>
    
    <span style='color:#7f0055; font-weight:bold; '>if</span>(!global_mouseButtonDown)
    {
        <span style='color:#7f0055; font-weight:bold; '>return</span> <span style='color:#7f0055; font-weight:bold; '>false</span>;   <span style='color:#3f7f59; '>//do nothing if the mouse button isn't pressed down</span>
        <span style='color:#3f7f59; '>//false is ok to return?</span>
    }
    
    doVerticalDragScrolling(<span style='color:#7f0055; font-weight:bold; '>this</span>, event.clientY);
    
    event.preventDefault();
}

<span style='color:#3f7f59; '>//Mouseup event handler for search results div</span>
<span style='color:#7f0055; font-weight:bold; '>function</span> mouseupForSearchResults(event)
{
    <span style='color:#3f7f59; '>//console.log('mouseup event on scrollable');</span>
    
    global_mouseButtonDown = <span style='color:#7f0055; font-weight:bold; '>false</span>;
    event.preventDefault(); <span style='color:#3f7f59; '>//need?</span>
}</code> 

<p>We simply recycle our existing scrolling helpers. The biggest difference is
we need to track if the mouse button is down or not as we don't
want to scroll on a mousemove when the mouse button isn't down.</p>

[NOTETOSELF mention using libraries for mobile touch scrolling etc]
[NOTETOSELF and the android webkit hack that you found]

<h3 id="the_search_tab_v">Extra credit challenges</h3>

<p>Solutions not provided. Try to add:</p>

<ol>
<li>"Content has become scrollable" indicator</li>
<li>"Can't scroll anymore" indicator (the "flare" that native Android scrolling usually has)</li>
<li>Our scrolling lacks the slippy, momentous feel that native Android scrolling usually has. Try to add this (this will be very challenging!).</li>
</ol>


# The *Write* tab {#chapter-10}

## Layout and interface {#chapter-10-1}

Our third and final tab now which is Write. This is more complex than the previous
Discover tab, but slightly quicker to implement than the first Search tab - mostly
due to not having any scrolling woes to care about.

The write tab is going to be a little scratchpad area for the user to practice
writing Japanese phonic characters. We'll present a random character and then an empty
canvas for the user to finger draw the character. A wireframe might look like this:

![Figure 43. Quick wireframe of the Write tab layout](images/fig_430.png)

We simply present a character and a space for them to practice drawing it in.

Let's start with the markup, and a dollop of CSS, first. Edit the write <div> of `index.html`
to look like this:

{lang="html"}
~~~~~~~~
<div id="write" class="current">
    <p style="text-align:center;">Write this character:
        <span style="font-size:2em;" id="char-to-write"></span>
        <span id="char-explanation"></span>
    </p>
    <canvas id="paper" width="300" height="300"></canvas>
    <br>    
    <button type="button" id="canvas-clear" style="width:45%; margin-right:1%; float:right;">
        <img src="img/paste.png"> Clear
    </button>
    <button type="button" id="canvas-new" style="width:45%; margin-left:1%;">
        <img src="img/file.png"> New character
    </button>
</div>
~~~~~~~~

(Note that, like we did with the Discover tab, we've temporarily made this content div - and it's corresponding tab - 
`class="current"` to speed up our development a tad.)

We have an explanatory paragraph for our random character, and placeholders for both the character
to write (in a larger font) and its explanation.

Then comes the magic and the main focus of this chapter, the whizz-bang HTML5 \<canvas>
element which you may or may not have seen before. It's an element that allows for
programmatic and interactive display and manipulation of simple 2D graphics.
It's kind of like Microsoft Paint but in the browser and you have to program it with JavaScript.
(It's actually *waaaaay* better than I've just made it sound!)

If you've got alarm bells ringing because we appear to have hard-coded the canvas dimensions
(300px x 300px) then you are right. We will come back and improve this shortly.

We end with two buttons, a Clear button which we want to erase the user's scribbling so far,
and a New character button which will display a new random Japanese character to draw.
Well if you run all of this, it looks like:

![Figure 44. Initial Write tab appearance](images/fig_440.png)

Clearly the \<canvas> needs a bit of styling. Add a style for the \<canvas> element to
`index.css` thus:

{lang="css"}
~~~~~~~~
canvas {
    border:1px solid grey;
    background-color:#ffa;  /*Post-It yellow*/
    margin-left:auto;       /*these two lines will*/
    margin-right:auto;      /*centre the element horizontally*/
    display:block;
}
~~~~~~~~

Running looks like this now:

![Figure 45. Write tab appearance with styled \<canvas>](images/fig_450.png)

Better!

## Filling the screen {#chapter-10-2}

Hmmm, but Android devices come in all shapes and sizes. What to do about the size of the canvas?
We would want, ideally, the biggest square (Japanese characters tend to be rather squareish) 
that would fit on the screen at that time - for portrait or lanscape.

We'll take an approach like this:

1. Put the two buttons at the bottom of the screen
2. Make a containing <div> for the \<canvas> that fills 100% of its available width and height
    (the height under "Write this character" and above the buttons, then the full width of the screen)
3. Set the size of the canvas to be the biggest *square* that will fit in this container. Centred
    in the container
4. When the device is rotated, we will have to resize the \<canvas> to be the biggest square
    in the newly created container size

OK, tackling [1] and [2] first, we need a new layout. We are going to do the same thing we did for
the app's header, content and footer; position them absolutely relative to parent. But this time the parent will be our .japxlate_app div.
Edit the write div in `index.html` to look like this:

{lang="html"}
~~~~~~~~
<div id="write" class="current">
    <p id="write-intro">Write this character: <span style="font-size:2em;" id="char-to-write"></span>
                <span id="char-explanation"></span>
    </p>
    <div id="write-canvas-container">
        <!--<canvas id="paper" width="300" height="300"></canvas>-->
    </div>
    <div id="write-buttons">
        <button type="button" id="canvas-clear" style="width:45%; margin-right:1%; float:right;">
            <img src="img/paste.png"> Clear
        </button>
        <button type="button" id="canvas-new" style="width:45%; margin-left:1%;">
            <img src="img/file.png"> New character
        </button>
    </div>
</div>
~~~~~~~~

We've given the intro paragraph an id. We've commmented the \<canvas> out for the time being
but we've put it in a container div of #write-canvas-container.
The buttons have also been placed in a containing div of #write-buttons.
Now we need to position and size these elements such that the intro paragraph will be right at the
top, the buttons will be right at the bottom, and the canvas container will fill **all**
the space inbetween.
Add these CSS rules to `index.css`:

{lang="css"}
~~~~~~~~
#write-intro {
    position:absolute;
    top:0;              /*absolute top of .japxlate_app*/
    height:40px;        /*make arbitrarily big enough for our 2em character*/
    width:100%;
    margin-bottom:0;    /*so #write-canvas-container is flush*/
    margin-top:10px;     /*so we aren't directly under the navigation tabs*/
    text-align:center;  /*centre text horizontally*/
    /*background-color:green;*/
}

#write-canvas-container {
    position:absolute;
    top:50px;           /*make flush with #write-intro*/
    bottom:40px;        /*stop 40px up from the botton of .japxlate_app*/
    width:100%;    
}

#write-buttons {
    position:absolute;
    bottom:0;           /*absolute bottom of .japxlate_app*/
    height:40px;        /*make flush with bottom of #write-canvas-container*/
    width:100%;
}
~~~~~~~~

We simply make write-intro and write-buttons a little bit bigger than they need to be, and set
canvas container to fill the remaining space.
We set margin-top of #write-intro to 10px so that the intro paragraph text is not too close to the tabs
and so that we know the top of #write-canvas-container is 50px.
We have previously set padding-top of .japxlate_app to 1em but this is obliterated with the
`position:absolute` and `top:0` of #write-intro.
(So yes, we've set a default top padding of 1em on .japxlate_app but only used it in the Search tab
as we positioned over it on the Discover tab and this tab!).
If you like you can confirm the size and shape of these divs by setting a different background-color
in each of the CSS rules and then changing the size of desktop Chrome or rotating your device.

For [3] we need to programatically get the dimensions of #write-canvas-container,
work out the biggest square that will fit in those dimensions (possibly trimming a bit off
so our canvas isn't too close to the buttons etc), and then dynamically add the appropriate
canvas element into #write-canvas-container - centreing it.

For [4] we need to catch a device rotation event and then do the steps for [3] again.

Create a file called `canvas.js` in `assets/www/js`. Include this JavaScipt file from the bottom
of `index.html` (above the include for `index.js`).

We are going to implement a function in `canvas.js` called `adjustCanvas()` which will be our step
[3]. `adjustCanvas()` looks like this:

{lang="js"}
~~~~~~~~
//adjust - creating if necessary - the canvas element
function adjustCanvas()
{
    var container = document.getElementById('write-canvas-container');
    
    var style = window.getComputedStyle(container);
    
    var width = parseInt(style.width);
    var height = parseInt(style.height);
    
    var smallestDim = width;    //smallest dimension is width (= portrait)
    
    if(height < width)  //ie. landscape
    {
        smallestDim = height;
    }
    
    //invisible frame around canvas so it's not flush with buttons etc
    var frameGap = 15;
    smallestDim -= (frameGap * 2);  //gap at top and bottom (left and right)
    
    var canvas = null;  //we proceed to get or create this
    
    //element existence check
    var firstTime = !document.getElementById('paper');
    
    if(firstTime)   //create canvas element with correct id
    {
        canvas = document.createElement('canvas');
        canvas.id = 'paper';
        canvas.style.position = 'relative'; //so we can "top" the canvas down
    }
    
    else    //get existing canvas element
    {
        canvas = document.getElementById('paper');
    }
    
    //size and position the canvas
    canvas.width = smallestDim;
    canvas.height = smallestDim;
    canvas.style.top = frameGap + 'px';
    
    //add canvas (as child of container) if first time
    if(firstTime)
    {
        container.appendChild(canvas);
    }
}
~~~~~~~~

Wow, this is our longest piece of JavaScript so far.
With the first two lines we get the container element for the \<canvas>, and its style.
We then save the width and height of the container.
We get the smallest dimension of the container (which will be the squared size of
our canvas) by assuming the container is portrait shaped. If container height is less than
container width, we say it is landscape shaped. (A perfectly square container will be covered by the
portrait assumption which will be fine as *any* of its side measurements is fine to use in that case.)
We then put an imaginary frame around the canvas of 15 pixels so that the bottom of the canvas
is not flush with our buttons.

Thinking ahead to step [4], it would be nice if this function to set up the \<canvas> initially could
also be used to adjust the canvas for a device rotate.
We tackle this with the concept of "first time". Basically, if the function is happening for the first time
 - ie. the canvas does not exist - then it must *create* the canvas. If not the first time
then it simply needs to alter the existing canvas.
We action this by:

{lang="js"}
~~~~~~~~
var firstTime = !document.getElementById('paper');
~~~~~~~~

Which relies on `document.getElementById('someId')` returning boolean false if an element with the id
of someId does not exist on the page.
So we get or create the canvas element and set its size to the smallest dimension of the container.
Minus our frame gap of course.
The first time around we have to insert the created \<canvas> element into the DOM
(`document.createElement('elementname');` creates the element in memory only)
which we do with `container.appendChild(canvas);`.

Go ahead and delete the line:

{lang="js"}
~~~~~~~~
canvas.style.position = 'relative';
~~~~~~~~

and put that in the `canvas{}` rule in `index.css` as that makes more sense.

Next, mosey on over to `firstLoadForTab_Write()` in `japxlate.js` and add a call to  
`adjustCanvas()` thus:

{lang="js"}
~~~~~~~~
function firstLoadForTab_Write()
{
    console.log('first load for write tab');
    
    adjustCanvas();    //create canvas element of correct size
    
    global_pagesLoaded.write = true;
}
~~~~~~~~

Remember `firstLoadForTab_Write()` is our one-off initialiser for the Write tab
and so running the app now looks like:

![Figure 46. \<canvas> now fills available space](images/fig_460.png)

Pretty good! You can test that the \<canvas> fills the available space by closing the page,
resizing the browser and loading the page again (desktop Chrome) or closing the app, rotating your phone,
reopening the app (device).

OK, that was actually the easy bit! Our next step is [4] and this is a bit fiddly as we
need to figure out how to detect a device rotation.

Well, the proper way is to catch the "orientationchange" event (of the window object)
with a handler.
(Interestingly there is no PhoneGap API to do this.)
 Orientationchange will fire for each and every orientation *change*
of the device. And then in that handler you can use the window.orientation
property to work out the device orientation.
Window.orientation will be 0 meaning portrait,
90 meaning landscape (top of phone pointing right) or
-90 meaning landscape (top of phone pointing left).
These values represent the number of degrees the phone has
been rotated from the resting - or zero - position which is
portrait.
Android does not allow the screen to be rotated upside-down and so there is no 180 value (phones only?).

As you would expect, our desktop Chrome browser doesn't
support the orientationchange event. (You can try to spin your monitor around but don't blame me if you wreck anything!).
Keeping our spirit of making the app work as an app and in 
the desktop Chrome, we are going to do something a little
different. (Although orientationchange is the "correct" way to do it.)

The closest thing to orientationchange on a desktop browser,
and something that will also work on our WebView browser,
is the "resize" event of the window object. This event fires
for every resize - big or small - of the browser window.
This includes the resize that our device will do to the
WebView when we rotate the device.

OK, let's get the ball rolling (or should that be rotating? LOL). Stick a call to  
`configureCanvasRotationAdjustment();`
at the bottom of `receivedEvent()` in `index.js`.
We define this function in `canvas.js`:

{lang="js"}
~~~~~~~~
//device "rotation" handler
function configureCanvasRotationAdjustment()
{
    window.addEventListener('resize', adjustCanvas, false);
}
~~~~~~~~

Run this and you can see that the \<canvas> resizes when
you rotate the device OR when you resize the desktop
Chrome.

But there's a problem, if you click on a different tab (not Write), rotate the device / resize
the browser and then click back on the Write tab, you get a tiny canvas like this:

![Figure 47. \<canvas> can become too small](images/fig_470.png)

What's happening is this: Our onresize handler (`adjustCanvas()`) triggers when the **browser**
resizes, regardless of whichever tab we are on.
The \<canvas> container will not be visible when not on the Write tab because of
our whole tabbing mechanism. But `adjustCanvas()` will still get called and create or adjust
the canvas. It seems like `.getComputedStyle()` picks up the \<canvas> container smallest dimension as
100px when it is not visible. This resizes the \<canvas> to a tiny size - it just isn't visible
until you click the Write tab.

Remember we put `adjustCanvas()` in `firstLoadForTab_Write()`?
This means that when we go back to the Write tab after clicking another tab, `adjustCanvas()` is **not** called.
One solution would be to somehow only action the resize handler when on the Write tab.
But what we will do instead is move the call to `adjustCanvas()` out of `firstLoadForTab_Write()`
and into `onclickForTab_Write()` such that the canvas is adjusted on every clicking
of the Write tab. So remove `adjustCanvas()` from `firstLoadForTab_Write()` and stick it in
`onclickForTab_Write()` so it looks like this:

{lang="js"}
~~~~~~~~
function onclickForTab_Write()
{
    console.log('click on write tab');
    
    if(!global_pagesLoaded.write)
    {
        firstLoadForTab_Write();
    }
    
    adjustCanvas(); //adjust - creating if necessary - the canvas element
}
~~~~~~~~

Run this and the problem has been resolved. Nice.

Phew, so the canvas display and layout is pretty hot and tasty right now and should be appropriate
for any device that the app runs on.

## Displaying a random character {#chapter-10-3}

Now, even before we get to the New character and Clear buttons, we need to present a random
Japanese character for the user to draw. And of course we need to make finger movements on the
canvas actually write something!

Put a call to the soon-to-be-implemented `doNewChar()` at the end of `onclickForTab_Write()` (so
that every click on the Write tab will present a new character to practice) such that it looks
like this:

{lang="js"}
~~~~~~~~
function onclickForTab_Write()
{
    console.log('click on write tab');
    
    if(!global_pagesLoaded.write)
    {
        firstLoadForTab_Write();
    }
    
    adjustCanvas(); //adjust - creating if necessary - the canvas element
    
    //get and display a random Japanese character to practice writing
    doNewChar();
}
~~~~~~~~

`doNewChar()` is going to get a random Japanese character, and display it above the canvas
for the user's reference. So before we implement `doNewChar()`, we need a slight detour - we
need the function to get a random Japanese character!
We will put this in, you guessed, `linguistics.js`:

{lang="js"}
~~~~~~~~
//return a random (non-chiisai, non-obsolete) hiragana or katakana
//RETURNs object like {char:'ã', romaji:'ku', type:'hiragana'}
function getRandomKana()
{
    //indices to ignore from coreHiragana:
    //64,65,68,>=74
    //so this is indices of coreHiragana of chars that we WANT to practice
    //(ie. not chiisai or obsolete):
    var coreIndices =
    [
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
        10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
        20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
        30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
        40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
        50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
        60, 61, 62, 63, 66, 67, 69, 70, 71, 72,
        73
    ];
    
    //get one of above indices at random
    var index = coreIndices[Math.floor(Math.random() * coreIndices.length)];
    
    //default to hiragana...
    var char = coreHiragana[index]; //use our random index
    var type = 'hiragana';
    
    //...but have a 50% chance of returning katakana
    if(Math.random() > 0.50)
    {
        char = hira_to_kata(char);
        type = 'katakana';
    }
    
    //return a useful object
    return {char:char, romaji:kana_to_romaji(char), type:type};
}
~~~~~~~~

This again might be something that's best ignored and treated as a black box, but basically we 
cherry pick a phonetic character from coreHiragana based on some desired indices (to give us a 
full size and non-obsolete character). We then convert that character into katakana
50% of the time. We return an object with the character itself and some metadata.

Let's use this function in `doNewChar()` which we define in `canvas.js`:

{lang="js"}
~~~~~~~~
//Get and display (with explanation) a random Japanese character
//to practice writing
function doNewChar()
{
    var randomKana = getRandomKana();
    
    document.getElementById('char-to-write').innerHTML = randomKana.char;
    
    document.getElementById('char-explanation').innerHTML = '("' + randomKana.romaji + '" in ' + randomKana.type + ')';
}
~~~~~~~~

Running the app now looks like this:

![Figure 48. Random Japanese character with metadata is displayed](images/fig_480.png)

Pretty cool! We get the random character to practice writing in a nice big font, the English
spelling / pronunciation and the type of script it's from.

Wait, I've just had a good idea. How about, before we let them start writing, if we flash up
the character on the canvas, filling the canvas and then fading out for them to start copying
it! That's gonna be awesome!

Note that this next bit (an initial, fading character on the \<canvas>) is going to be somewhat difficult and involves recursive
JavaScript.

We'll want to do this character fading for every new character that we present. So a good place
to call our fading function will be from `doNewChar()` in `canvas.js`.
Add this as the last line in `doNewChar()`:

{lang="js"}
~~~~~~~~
//put character on canvas and fade to nothing (starting at 1 opacity)
//our trademark #990000 red is rgb(153, 0, 0)
fadeCharOnCanvas(randomKana.char, 153, 0, 0, 1, 1, 100, 10);
~~~~~~~~

We call `fadeCharOnCanvas()` with a **lot** of parameters.
Let's implement `fadeCharOnCanvas()` - also in `canvas.js` - right now.
It's a biggie because it uses a few helper functions and variables that we'll implement shortly.
So don't be scared if you see something that hasn't been referenced yet! OK, implement `fadeCharOnCanvas()`
to look like this:

{lang="js"}
~~~~~~~~
//Animate a fade out of a single (Japanese) character on the canvas.
//Starting from opacity of startAlpha and stepping down to zero opacity
function fadeCharOnCanvas(char, startR, startG, startB, startAlpha, thisAlpha, msDelay, frameCount)
{
    //calc the step down amount
    var dec = startAlpha / frameCount;
    
    //what will the *next* opacity be?
    var nextAlpha = thisAlpha - dec;
    
    //console.log('thisAlpha:' + thisAlpha + ' -- nextAlpha:' + nextAlpha);
    
    //dues to floating point rounding we prob won't reach exactly zero
    //BUT we want exactly zero for the char to disappear
    //SO if thisAlpha is on the last frame, force to zero
    if(thisAlpha <= (startAlpha - ((frameCount - 1) * dec)))
    {
        //console.log('last frame reached');
        thisAlpha = 0;
    }
    
    clearCanvas();  //else we are drawing a lighter char over a darker one!
    
    //console.log(global_canvasElement.width);
    var fontSize = parseInt(global_canvasElement.width * 0.833);
    //console.log(fontSize);
    global_canvas.font = 'normal ' + fontSize + 'px serif';
    global_canvas.fillStyle = 'rgba(' + startR + ',' + startG + ',' + startB + ',' + thisAlpha + ')';    //rgb alpha
    global_canvas.fillText(char, parseInt(global_canvasElement.width * 0.05), parseInt(global_canvasElement.width * 0.78));
    
    if(nextAlpha < 0)
    {
        //console.log('last frame drawn - exiting');
        return;
    }
    
    //recurse!
    setTimeout(function(){fadeCharOnCanvas(char, startR, startG, startB, startAlpha, nextAlpha, msDelay, frameCount)}, msDelay);
}
~~~~~~~~

The \<canvas> API lets us write text in any colour and at any opacity. We set the opacity using what's called an *alpha*
value; one meaning fully opaque and zero meaning fully transparent. In a nutshell, we simply
draw the character on the canvas a bunch of times and increase the transparency at each step.
OK, let's have a fuller explanation...

We accept, in order of appearance, these parameters:

1. char - the single Japanese character to draw
2. startR - red element of colour to use for drawing (integer 0 - 255)
3. startG - green element of colour to use for drawing (integer 0 - 255)
4. startB - blue element of colour to use for drawing (integer 0 - 255)
5. startAlpha - opacity used to draw the *first* frame (float 0.0 - 1.0)
6. thisAlpha - opacity used to draw the *current* frame (float 0.0 - 1.0)
7. msDelay - the delay, in milliseconds, between each frame
8. frameCount - how many frames to take to get down to zero opacity

(Note that startR, startG and startB don't actually change value at any step of the recursion.)

We save in `dec` the amount we have to decrement the starting opacity (startAlpha) by each step
to reach zero opacity after the specified number of frames (frameCount).

We then use `dec` to work out what the opacity of the *next* frame will be. We'll use this value a bit later on.

Next we have a workaround for the vagaries of floating point arithmetic. Basically, due to
rounding, we might not reach an opacity of exactly zero on our last frame. So we do an `if`
check here to see if we are more-or-less on the last frame now (ie. (frameCount - 1) frames have already happened).
If we are, we force the current opacity to zero.

Next, and before we draw anything, we clear the canvas. We will define `clearCanvas()` shortly.

Next we calculate `fontSize` to make the character best fill the canvas.
During development I saw that for a 300px by 300px canvas, a font size of 250px was best.
This is the equivalent of the font size being 83.3% of the canvas size. Trial-and-error
with some different canvas sizes told me that this percentage *just works*.
`global_canvasElement` is the \<canvas> DOM element
which we need to have available when this function is called.

Next we use the `font` property of `global_canvas` to set the font size
we just calculated. `global_canvas` is the *drawing context* of our \<canvas> element
which we need to have available when this function is called. We cover this shortly so don't worry.

Next we use an rgba ("red, green, blue, alpha") value to set the `global_canvas.fillStyle` property. This sets
the colour and opacity that our character will get drawn with.

Then we call `global_canvas.fillText()` which actually writes our character on the canvas.
The second argument is the canvas x coordinate where you want the (left edge of the) text to start drawing.
The third argument is the canvas y coordinate where you want the (bottom baseline of the) text to be.
Again by trial-and-error I saw it was best for the x coordinate to be 5% of the canvas total width,
and the y coordinate to be 78% of the canvas total height.

OK, that's one frame drawn, but we are still in the function and so we need to exit the function
if we have just drawn the last frame. That's what we do with the next `if` check.

Last but not least, if we are still in the function then we have another frame to draw. We
make the function call itself (*recursion*) at the end. **But** this should
only happen after the specified delay (msDelay) and so we use JavaScript's builtin `setTimeout()`
method (of the `window` object) to call ourself after the delay. `setTimeout()` works like
`setTimeout(someCallableThing, delayInMilliseconds);`. We simply call ourself with the updated
value for nextAlpha - all the other arguments are the same.

Great! But we still need to define `clearCanvas()` and initialise `global_canvas`
and `global_canvasElement`. Let's do the globals first, define them at the top of `canvas.js`
like this:

{lang="js"}
~~~~~~~~
//The drawing context of our <canvas>
var global_canvasElement;

//Our <canvas> DOM element
var global_canvas;
~~~~~~~~

Nothing difficult there. Now, again in `canvas.js`, define `initialiseCanvas()`
thus:

{lang="js"}
~~~~~~~~
//Save our global canvas variables
function initialiseCanvas()
{
    //set the globals
    global_canvasElement = document.getElementById('paper');
    global_canvas = global_canvasElement.getContext('2d');
}
~~~~~~~~

Good old `document.getElementById()` is used to save the canvas DOM element into `global_canvasElement`.
For `global_canvas` we call `getContext('2d')` on our canvas DOM element.
This is a builtin method of the HTML5 canvas object and will return an API for 2D drawing.
(Yes, there's a 3D API - `getContext('webgl')` - but it won't work in as many browsers as the 2D API.)

The question now is where to call `initialiseCanvas()`?
If you're thinking that we need to call it once and only once, then you're thinking the same as me.
However, during development I noticed an obscure quirk with the canvas drawing context whenever
the canvas was resized (ie. we rotate our device): the canvas drawing context would reset!
With this in mind we need to call `initialiseCanvas()` **every** time
the canvas is adjusted. This is actually easy to do and simply involves adding:

{lang="js"}
~~~~~~~~
initialiseCanvas();
~~~~~~~~

as the very last line of `adjustCanvas()`.

Just `clearCanvas()` left now. Stick it in `canvas.js` and it goes like:

{lang="js"}
~~~~~~~~
//Clear the canvas
function clearCanvas()
{
    global_canvas.clearRect(0, 0, global_canvasElement.width, global_canvasElement.height);
}
~~~~~~~~

We use the `clearRect()` canvas API method to clear a rectangle on the canvas. The rectangle we clear starts at (0, 0) in canvas space
and the width and height matches that of the canvas itself. This clears the entire canvas.

All done! You should now get the Japanese character fading down on the canvas for each new character!

## Finger doodling {#chapter-10-4}

Right, on to the biggie now which is making something draw on the canvas when the user moves
their finger in there.
Do you remember our work on finger scrolling for the Search tab? Remember we got it working
on the device first then we simulated finger presses - using mouse events - for debugging
in desktop Chrome? Well, let's do it the other way round this time. Let's get canvas
writing working on desktop Chrome first.

When the mouse is down in the canvas, and then the mouse is moved, we want to leave a "trail"
on the canvas as if drawing with a calligraphy brush or what-have-you.
I mentioned earlier that HTML5 canvas is somewhat like MS Paint in the browser. Like MS Paint,
it has a line drawing API where we can start the "brush" at a certain coordinate, and then
paint a line from there to any other coordinate.

And, like we did for simulated finger scrolling, we are going to need a global variable
to track the mouse downness. In fact, we'll recycle the same global variable (so yes, it
might not *logically* belong in a file called search_interface.js).

You remember our `initialiseCanvas()` in `canvas.js` which is where we stored the canvas
in global variables just after creating it for the first time.
That seems like a good place to put the event listeners we're going to need
for our mouse drawing.
Add three `addEventListener()` calls - on the canvas element - at the bottom of `initialiseCanvas()`
such that it now looks like this:

{lang="js"}
~~~~~~~~
function initialiseCanvas()
{
    //set the globals
    global_canvasElement = document.getElementById('paper');
    global_canvas = global_canvasElement.getContext('2d');
    
    //simulated touch (ie. mouse) dragging for writing pad
    global_canvasElement.addEventListener('mousedown', mousedownForCanvas, false);
    global_canvasElement.addEventListener('mousemove', mousemoveForCanvas, false);
    global_canvasElement.addEventListener('mouseup', mouseupForCanvas, false);
}
~~~~~~~~

You've guessed it, we're going to define `mousedownForCanvas()`, `mousemoveForCanvas()` and
`mouseupForCanvas()` right now; also in `canvas.js`:

{lang="js"}
~~~~~~~~
//Mousedown event handler for canvas - set "now drawing" state
function mousedownForCanvas(event)
{
    global_mouseButtonDown = true;
    event.preventDefault();
}

//Mousemove event handler for canvas - draw on canvas
function mousemoveForCanvas(event)
{
    var x, y;
    
    // Get the mouse position relative to the canvas element.
    //(ie. the mouse position IN CANVAS SPACE)
    if (event.offsetX || event.offsetX == 0) { // Opera and Chrome
      x = event.offsetX;
      y = event.offsetY;
    }

    //This event handler works like a drawing pencil which tracks the mouse 
    //movements. We start drawing a path made up of lines.
    if(global_mouseButtonDown)
    {
        doDrawOnCanvas(x, y);    //our canvas API magic
    }
}

//Mouseup event handler for canvas - unset "now drawing" state
function mouseupForCanvas(event)
{
    //console.log('mouseup event on canvas');
    
    global_mouseButtonDown = false;
    global_startedDrawing = false;
    event.preventDefault();
}
~~~~~~~~

`mousedownForCanvas()` simply sets our recycled global_mouseButtonDown to true.
In  
`mousemoveForCanvas()` we receive the mouse event and, if the mouse button is
down, call `doDrawOnCanvas()` with canvas space x and y coordinates.
Specifically we pass it offsetX and offsetY of the mouse event. 
In Chrome (and also Opera but definitely not Firefox), this is the xy coords
of the mouse event but offset to be in element space. Element space meaning
the very top-left of the element is x=0, y=0 and so on.

Why call `doDrawOnCanvas()` and not just do the canvas drawing logic in the 
mousemove handler? Well it's because, like we did for search results scrolling,
we want to reuse the same logic for actual finger drawing and simulated finger drawing
with the mouse. We'll get on to `doDrawOnCanvas()` in a moment.

Finally in `mouseupForCanvas()` we set global_mouseButtonDown to false.
We also set global_startedDrawing to false but we haven't defined that yet.
Let's define it first then I'll explain. Stick:

{lang="js"}
~~~~~~~~
//Are we already drawing on the canvas?
var global_startedDrawing = false;
~~~~~~~~

at the top of `canvas.js` with the other globals.

We need to keep track of this because, as we will see shortly, with canvas API
we have two very distinct steps of drawing lines; moving the brush to a certain point to
start the path and then actually moving the brush from that point.
So most of the magic happens in our `doDrawOnCanvas()` which we will define right now, also
in `canvas.js`:

{lang="js"}
~~~~~~~~
//Universal canvas line plotter. for onmousemove etc
function doDrawOnCanvas(canvasX, canvasY)
{
    //This works like a drawing pencil which tracks the mouse / touch 
    //movements. We draw a path made up of lines.
    if(!global_startedDrawing) //first time
    {
        global_canvas.beginPath();
        global_canvas.moveTo(canvasX, canvasY);
        global_startedDrawing = true;
    }
    
    else
    {
        global_canvas.lineTo(canvasX, canvasY);
        global_canvas.stroke();
    }
}
~~~~~~~~

We expect to receive x and y coordinates in canvas space, which is conveniently provided
by .offsetX and Y on the mousemove event. (The offsetX and Y properties will contain
the screen coordinates of the mouse converted into element space such that
if the mouse is in the very top-left of the element - our canvas - the offsetX and Y
will be 0,0.)

For the first time that drawing has started, we call a couple of canvas API methods
to get ready for drawing. We call `beginPath()` which starts a new path. A path is
basically a line or curve that we draw onto the canvas. We then call `moveTo()` which
positions the "brush" but does not actually paint anything.
We then, for subsequent mousemoves or finger drags set global_startedDrawing to true
so that the next bit can happen...

Which is simply to call two more canvas API methods. We call `lineTo()` with the updated
mouse / finger position (again in canvas space) which will move the brush from its
path starting point to the point specified. Note that even this will not paint anything 
on the canvas. For that we need to call `stroke()` which will actually follow the path and
put the "ink" down.

Give it a whirl in desktop Chrome! You should be able to paint on the canvas using the mouse!

![Figure 49. Canvas painting with mouse](images/fig_490.png)

Hmmm, but that thin black line doesn't feel so great.
Let's fatten it out and make it our signature red.
HTML5 canvas exposes a bunch of properties that we can
tinker with to affect line drawing style.
The right place to change these settings feels
like our one-off canvas initialiser of `initialiseCanvas()`.
Add two lines to the bottom so it looks like:

{lang="js"}
~~~~~~~~
function initialiseCanvas()
{
    //set the globals
    global_canvasElement = document.getElementById('paper');
    global_canvas = global_canvasElement.getContext('2d');
    
    //simulated touch (ie. mouse) dragging for writing pad
    global_canvasElement.addEventListener('mousedown', mousedownForCanvas, false);
    global_canvasElement.addEventListener('mousemove', mousemoveForCanvas, false);
    global_canvasElement.addEventListener('mouseup', mouseupForCanvas, false);
    
    //line drawing style
    global_canvas.strokeStyle = '#990000'; //our trademark red
    global_canvas.lineWidth = 10;
}
~~~~~~~~

We can set the colour that `stroke()` will use with 
.strokeStyle. We can set the line width with, yes,
.lineWidth.

Try it!:

![Figure 50. Line angles and edges somewhat jaggedy](images/fig_500.png)

Much better! The red looks great and it feels nice and fat
like a calligraphy brush. But, and this is much easier
to notice when you're actually drawing with it and not looking
at this screenshot, there's something not quite right.
The drawn line seems to have some quite sharp edges
and generally looks jaggedy.

Digging deeper into the canvas API, we have some interesting properties to change the
brush drawing style.
The lineJoin property of the canvas  
([http://www.html5canvastutorials.com/tutorials/html5-canvas-line-joins](http://www.html5canvastutorials.com/tutorials/html5-canvas-line-joins) is a useful page) specifies how we want to draw the "join"
between two lines which in our case basically means the point where
we change the direction of drawing with our brush.
The default is "miter" which is a very sharp join. You can see this on the above
figure.
The remaining options are "bevel" and "round". We'll go for round
as this most resembles what a calligraphy brush would do.

There is also the "lineCap" property ([http://www.html5canvastutorials.com/tutorials/html5-canvas-line-caps](http://www.html5canvastutorials.com/tutorials/html5-canvas-line-caps) is a useful page) which is how to draw the end of the line.
As you can see from the above figure, the default is "square".
For that calligraphy feel, let's make this also "round".
So add to the end of `initialiseCanvas()` so it looks like this:

{lang="js"}
~~~~~~~~
function initialiseCanvas()
{
    //set the globals
    global_canvasElement = document.getElementById('paper');
    global_canvas = global_canvasElement.getContext('2d');
    
    //simulated touch (ie. mouse) dragging for writing pad
    global_canvasElement.addEventListener('mousedown', mousedownForCanvas, false);
    global_canvasElement.addEventListener('mousemove', mousemoveForCanvas, false);
    global_canvasElement.addEventListener('mouseup', mouseupForCanvas, false);
    
    //line drawing style
    global_canvas.strokeStyle = '#990000'; //our trademark red
    global_canvas.lineWidth = 10;
    global_canvas.lineCap = 'round';   //dat calligraphy feel
    global_canvas.lineJoin = 'round';   //dat calligraphy feel
}
~~~~~~~~

Try running the app now and it draws like this:

![Figure 51. Line angles and ends have a rounder feel](images/fig_510.png)

Awesome! I feel warm and fuzzy inside.

Right, let's quickly get our bottom buttons in the bag and then we'll
get our calligraphy brush working with our sticky fingers on our actual device.
Okey dokey, we're going to need some event handlers to do the appropriate things
for our New character and Clear buttons. Stroll over to `index.js` and whack a call to
`configureCanvasButtons();` at the end of `receivedEvent()`. `receivedEvent()` will
look like this now:

{lang="js"}
~~~~~~~~
// Update DOM on a Received Event
    receivedEvent: function(id) {
        console.log('Received Event: ' + id);
        
        configureTabs();
        
        //load and show whatever we've set the initial tab to be
        initialiseDefaultTab();
        
        configureSearchButton();
        
        configureSearchInput();
        
        configureSearchTouchScrolling();
        
        configureSearchMouseScrolling();
        
        configureCanvasRotationAdjustment();
        
        configureCanvasButtons();
    },
~~~~~~~~

We'll define `configureCanvasButtons()` in `canvas.js` thus:

{lang="js"}
~~~~~~~~
//"New character" and "Clear" buttons
function configureCanvasButtons()
{
    document.getElementById('canvas-clear').addEventListener('click', clearCanvas, false);
    document.getElementById('canvas-new').addEventListener('click', doNewChar, false);
}
~~~~~~~~

And that's it! The Clear button simply calls our existing `clearCanvas()` function,
and the New character button simply calls our existing `doNewChar()` function.
Try it! The write tab is much more fun now!

Right, the remaining matter is the important one of getting drawing to work
with finger moves on the device itself. We are happy with how it works in desktop Chrome
now so let's move forward and think about the device.
We isolated the `doDrawOnCanvas()` function and it is ready to accept canvas coordinates
from *any* event, not just mouse events.

Just like with search results scrolling, the events in question are touchstart, touchmove
and touchend. These will somewhat correlate with the mousedown, mousemove and mouseup
handlers (respectively) that we've just implemented.

In `initialiseCanvas()` in `canvas.js`, go ahead and insert these three lines to add
our touch event handlers. Insert them after the mouse event handlers:

{lang="js"}
~~~~~~~~
//touch dragging for writing pad
global_canvasElement.addEventListener('touchstart', touchstartForCanvas, false);
global_canvasElement.addEventListener('touchmove', touchmoveForCanvas, false);
global_canvasElement.addEventListener('touchend', touchendForCanvas, false);
~~~~~~~~

Great, now let's define these handlers; again in `canvas.js`:

{lang="js"}
~~~~~~~~
//Touchstart event handler for canvas
function touchstartForCanvas(event)
{
    //console.log('touchstart event on canvas');
    
    event.preventDefault();
}

//Touchmove event handler for canvas - draw on canvas
function touchmoveForCanvas(event)
{
    var touchobj = event.changedTouches[0]; //reference first touch point for this event
    
    //where, in canvas space, has been touched?
    var x, y;
    
    x = touchobj.offsetX;
    y = touchobj.offsetY;
  
    doDrawOnCanvas(x, y);
}

//Touchend event handler for canvas - unset "now drawing" state
function touchendForCanvas(event)
{
    //console.log('touchend event on canvas');
    
    global_startedDrawing = false;
    
    event.preventDefault();
}
~~~~~~~~

We don't actually do anything in the touchstart handler, but we'll keep it
in case we do need to do anything in future.

In the touchmove handler we get the first touch point and, like we did for mousemove,
pass its offsetX and Y to `doDrawOnCanvas()`.

Finally the touchend handler simply sets the global "started drawing" state to false;
ready for the next scribble.

OK, so run this on your device and, hmmmm, finger drawing does not work! What gives?
The problem is that the touch object we get from the touchmove event does not
have offsetX or Y properties! Nor does the touchmove event itself! This is officially
A Very Annoying Thing. I think the JavaScript implementors are missing a bit of a trick
here honestly.
Without offsetting the touch object coordinates, they will be screen coordinates
and will not correlate to canvas space. They will basically be too big to point to anywhere
meaningful in the canvas.

The good news is that every DOM element under <body> exposes some offset properties.
Specifically we have .offsetParent which points to an element's parent element, and we
have .offsetLeft and .offsetTop which tell us, in pixels, how far away from the top-left
of the parent the top-left of the element is.

The bad news is that most elements, in particular our canvas, have multiple parents.
We are going to have to programatically loop up through an element's parents and
tot up the offsets to work out a true screen offset of an element. It's actually a trivial function
and let's put it in `canvas.js`:

{lang="js"}
~~~~~~~~
//Get DOM element position on page
function getPosition(obj)
{
    var x = 0, y = 0;
    
    if (obj.offsetParent)
    {
        do
        {
            x += obj.offsetLeft;
            y += obj.offsetTop;
            obj = obj.offsetParent;
        }
        while(obj);
    }
    
    return {'x':x, 'y':y};
};
~~~~~~~~

We accept a DOM element in obj. We start the x and y values - our offset - at zero.
Then, if we have an .offsetparent on obj (if not then it is <body> and will have no parent)
we loop (at least once) cumulatively adding .offsetLeft to x and .offsetTop to y.
We loop as long as there is a parent up the chain.
We return the coordinates in a little object.

Right, with this we can go back and fix `touchmoveForCanvas()`. Edit `touchmoveForCanvas()`
to look like this:

{lang="js"}
~~~~~~~~
function touchmoveForCanvas(event)
{
    var touchobj = event.changedTouches[0]; //reference first touch point for this event
    
    //where, in canvas space, has been touched?
    var x, y;
    
    var canvasOffset = getPosition(global_canvasElement);   //why no offset x and y for if it's a touch event? :-(
    x = touchobj.screenX - canvasOffset.x;
    y = touchobj.screenY - canvasOffset.y;
  
    doDrawOnCanvas(x, y);
}
~~~~~~~~

Run this on your device. It works!

OMG, we've nailed it, we've finished all the tabs! Crack open the beers at this point ;-)

Just two more easy things. Let's have a splashscreen that displays while we are
waiting for the app to start. Also, we're going to need something other than PhoneGap's
default launcher icon!

## Extra credit challenges {#chapter-10-5}

Solutions not provided.

### Easy

X> Prevent the current character from being displayed again when clicking the New character button

### Medium

The way we have centred the big fading character on the \<canvas> is slightly ridiculous.

X> Use the \<canvas> API to *properly* centre the character on the \<canvas> [NOTETOSELF find the good link for this]

### Difficult

Technically what we are doing here for finger doodling is following the mouse or finger and, underneath it,
creating a multi-sectional line. We aren't actually simply placing a pixel under the
mouse or finger. Now, the effect is the same so it mostly doesn't matter, but there
is a side effect of doing it this way which is that, on the device, if you draw a very quick
semi-circle, for example, it will end up looking like this:

![Figure 52. Imperfect lines can be created](images/fig_520.png)

X> Re-engineer finger doodling to use HTML5 canvas's pixel manipulation API and see if that solves this problem.
X> [http://beej.us/blog/data/html5s-canvas-2-pixel](http://beej.us/blog/data/html5s-canvas-2-pixel) is a useful reference here (though a few years old now)

